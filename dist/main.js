/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/CardStatus.json":
/*!*****************************!*\
  !*** ./src/CardStatus.json ***!
  \*****************************/
/*! exports provided: Airman, Alpha, Beta, Gamma, MagicianOfChaos, CyberVary, Disk, Dogma, Kuraz, DDR, DestinyDraw, DimensionFusion, GoldSalcophagus, HandDestruction, HiddenArmory, Hurricane, MagicStoneExcavation, MonsterGate, MonsterReborn, PhenixBlade, PrematureBrial, Reasoning, Reinforcement, SpellEconomics, TradeIn, MagicalExplosion, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"Airman\\\":{\\\"imageFileName\\\":\\\"Airman.jpg\\\",\\\"ID\\\":\\\"40044918\\\",\\\"cardName\\\":\\\"Airman\\\",\\\"cardNameJP\\\":\\\"E・HERO エアーマン\\\",\\\"category\\\":[\\\"HERO\\\"],\\\"cardType\\\":\\\"Monster\\\",\\\"monsterType\\\":\\\"Effect\\\",\\\"level\\\":4,\\\"race\\\":\\\"WARRIOR\\\",\\\"attribute\\\":\\\"WIND\\\",\\\"atkPoint\\\":1800,\\\"defPoint\\\":300,\\\"effectKey\\\":\\\"AIRMAN\\\",\\\"text\\\":\\\"このカードが召喚・特殊召喚に成功した時、以下の効果から１つを選択して発動できる。●このカード以外の自分フィールドの「ＨＥＲＯ」モンスターの数まで、フィールドの魔法・罠カードを選んで破壊する。●デッキから「ＨＥＲＯ」モンスター１体を手札に加える。\\\"},\\\"Alpha\\\":{\\\"imageFileName\\\":\\\"Alpha.jpg\\\",\\\"ID\\\":\\\"99785935\\\",\\\"cardName\\\":\\\"Alpha\\\",\\\"cardNameJP\\\":\\\"磁石の戦士α\\\",\\\"cardType\\\":\\\"Monster\\\",\\\"monsterType\\\":\\\"Normal\\\",\\\"level\\\":4,\\\"race\\\":\\\"ROCK\\\",\\\"attribute\\\":\\\"EARTH\\\",\\\"atkPoint\\\":1400,\\\"defPoint\\\":1700},\\\"Beta\\\":{\\\"imageFileName\\\":\\\"Beta.jpg\\\",\\\"ID\\\":\\\"39256679\\\",\\\"cardName\\\":\\\"Beta\\\",\\\"cardNameJP\\\":\\\"磁石の戦士β\\\",\\\"cardType\\\":\\\"Monster\\\",\\\"monsterType\\\":\\\"Normal\\\",\\\"level\\\":4,\\\"race\\\":\\\"ROCK\\\",\\\"attribute\\\":\\\"EARTH\\\",\\\"atkPoint\\\":1400,\\\"defPoint\\\":1700},\\\"Gamma\\\":{\\\"imageFileName\\\":\\\"Gamma.jpg\\\",\\\"ID\\\":\\\"11549357\\\",\\\"cardName\\\":\\\"Gamma\\\",\\\"cardNameJP\\\":\\\"磁石の戦士γ\\\",\\\"cardType\\\":\\\"Monster\\\",\\\"monsterType\\\":\\\"Normal\\\",\\\"level\\\":4,\\\"race\\\":\\\"ROCK\\\",\\\"attribute\\\":\\\"EARTH\\\",\\\"atkPoint\\\":1400,\\\"defPoint\\\":1700},\\\"MagicianOfChaos\\\":{\\\"imageFileName\\\":\\\"MagicianOfChaos.jpg\\\",\\\"ID\\\":\\\"40737112\\\",\\\"cardName\\\":\\\"MagicianOfChaos\\\",\\\"cardNameJP\\\":\\\"混沌の黒魔術師\\\",\\\"cardType\\\":\\\"Monster\\\",\\\"monsterType\\\":\\\"Effect\\\",\\\"level\\\":8,\\\"race\\\":\\\"SPELLCASTER\\\",\\\"attribute\\\":\\\"DARK\\\",\\\"atkPoint\\\":2800,\\\"defPoint\\\":2600,\\\"effectKey\\\":\\\"MAGICIANOFCHAOS\\\",\\\"text\\\":\\\"このカードが召喚・特殊召喚に成功した時、自分の墓地から魔法カード１枚を選択して手札に加える事ができる。このカードが戦闘によって破壊したモンスターは墓地へは行かずゲームから除外される。このカードはフィールド上から離れた場合、ゲームから除外される。\\\"},\\\"CyberVary\\\":{\\\"imageFileName\\\":\\\"CyberVary.jpg\\\",\\\"ID\\\":\\\"03657444\\\",\\\"cardName\\\":\\\"CyberVary\\\",\\\"cardNameJP\\\":\\\"サイバー・ヴァリー\\\",\\\"category\\\":[],\\\"cardType\\\":\\\"Monster\\\",\\\"monsterType\\\":\\\"Effect\\\",\\\"level\\\":1,\\\"race\\\":\\\"MACHINE\\\",\\\"attribute\\\":\\\"LIGHT\\\",\\\"atkPoint\\\":0,\\\"defPoint\\\":0,\\\"effectKey\\\":\\\"CYBERVARY\\\",\\\"text\\\":\\\"以下の効果から１つを選択して発動できる。●自分のメインフェイズ時に発動できる。このカードと自分フィールド上に表側表示で存在するモンスター１体を選択して除外し、その後デッキからカードを２枚ドローする。●自分のメインフェイズ時に、自分の墓地のカード１枚を選択して発動できる。このカードと手札１枚を除外し、その後選択したカードをデッキの一番上に戻す。\\\"},\\\"Disk\\\":{\\\"imageFileName\\\":\\\"Disk.jpg\\\",\\\"ID\\\":\\\"56570271\\\",\\\"cardName\\\":\\\"Disk\\\",\\\"cardNameJP\\\":\\\"D-HERO ディスクガイ\\\",\\\"category\\\":[\\\"HERO\\\",\\\"D-HERO\\\"],\\\"cardType\\\":\\\"Monster\\\",\\\"monsterType\\\":\\\"Effect\\\",\\\"level\\\":1,\\\"race\\\":\\\"WARRIOR\\\",\\\"attribute\\\":\\\"DARK\\\",\\\"atkPoint\\\":300,\\\"defPoint\\\":300,\\\"effectKey\\\":\\\"DISK\\\",\\\"text\\\":\\\"このカードが墓地からの特殊召喚に成功した場合に発動できる。自分はデッキから２枚ドローする。\\\"},\\\"Dogma\\\":{\\\"imageFileName\\\":\\\"Dogma.jpg\\\",\\\"ID\\\":\\\"17132130\\\",\\\"cardName\\\":\\\"Dogma\\\",\\\"cardNameJP\\\":\\\"D-HERO ドグマガイ\\\",\\\"category\\\":[\\\"HERO\\\",\\\"D-HERO\\\"],\\\"cardType\\\":\\\"Monster\\\",\\\"monsterType\\\":\\\"Effect\\\",\\\"canNS\\\":false,\\\"level\\\":8,\\\"race\\\":\\\"WARRIOR\\\",\\\"attribute\\\":\\\"DARK\\\",\\\"atkPoint\\\":3400,\\\"defPoint\\\":2400,\\\"effectKey\\\":\\\"DOGMA\\\",\\\"SSconditionKey\\\":\\\"DOGMA\\\",\\\"text\\\":\\\"このカードは通常召喚できない。「Ｄ－ＨＥＲＯ」モンスターを含む自分フィールドのモンスター３体をリリースした場合のみ特殊召喚できる。(1)：この方法でこのカードが特殊召喚に成功した場合、次の相手スタンバイフェイズに発動する。相手のＬＰを半分にする。\\\"},\\\"Kuraz\\\":{\\\"imageFileName\\\":\\\"Kuraz.jpg\\\",\\\"ID\\\":\\\"57666212\\\",\\\"cardName\\\":\\\"Kuraz\\\",\\\"cardNameJP\\\":\\\"光帝クライス\\\",\\\"category\\\":[],\\\"cardType\\\":\\\"Monster\\\",\\\"monsterType\\\":\\\"Effect\\\",\\\"level\\\":6,\\\"race\\\":\\\"WARRIOR\\\",\\\"attribute\\\":\\\"LIGHT\\\",\\\"atkPoint\\\":2400,\\\"defPoint\\\":1000,\\\"effectKey\\\":\\\"KURAZ\\\",\\\"text\\\":\\\"(1)：このカードが召喚・特殊召喚に成功した時、フィールドのカードを２枚まで対象として発動できる。そのカードを破壊し、破壊されたカードのコントローラーは破壊された枚数分だけデッキからドローできる。(2)：このカードは召喚・特殊召喚したターンには攻撃できない。\\\"},\\\"DDR\\\":{\\\"imageFileName\\\":\\\"DDR.jpg\\\",\\\"ID\\\":\\\"33064647\\\",\\\"cardName\\\":\\\"DDR\\\",\\\"cardNameJP\\\":\\\"D・D・R\\\",\\\"cardType\\\":\\\"Spell\\\",\\\"spellType\\\":\\\"Equip\\\",\\\"effectKey\\\":\\\"DDR\\\",\\\"text\\\":\\\"(1)：手札を１枚捨て、除外されている自分のモンスター１体を対象としてこのカードを発動できる。そのモンスターを攻撃表示で特殊召喚し、このカードを装備する。このカードがフィールドから離れた時にそのモンスターは破壊される。\\\"},\\\"DestinyDraw\\\":{\\\"imageFileName\\\":\\\"DestinyDraw.jpg\\\",\\\"ID\\\":\\\"45809008\\\",\\\"cardName\\\":\\\"DestinyDraw\\\",\\\"cardNameJP\\\":\\\"デステニー・ドロー\\\",\\\"cardType\\\":\\\"Spell\\\",\\\"spellType\\\":\\\"Normal\\\",\\\"effectKey\\\":\\\"DESTINYDRAW\\\",\\\"text\\\":\\\"(1)：手札から「Ｄ－ＨＥＲＯ」カード１枚を捨てて発動できる。自分はデッキから２枚ドローする。\\\"},\\\"DimensionFusion\\\":{\\\"imageFileName\\\":\\\"DimensionFusion.jpg\\\",\\\"ID\\\":\\\"23557835\\\",\\\"cardName\\\":\\\"DimensionFusion\\\",\\\"cardNameJP\\\":\\\"次元融合\\\",\\\"cardType\\\":\\\"Spell\\\",\\\"spellType\\\":\\\"Normal\\\",\\\"effectKey\\\":\\\"DIMENSIONFUSION\\\",\\\"text\\\":\\\"２０００ライフポイントを払う。お互いに除外されたモンスターをそれぞれのフィールド上に可能な限り特殊召喚する。\\\"},\\\"GoldSalcophagus\\\":{\\\"imageFileName\\\":\\\"GoldSarcophagus.jpg\\\",\\\"ID\\\":\\\"75500286\\\",\\\"cardName\\\":\\\"GoldSarcophagus\\\",\\\"cardNameJP\\\":\\\"封印の黄金櫃\\\",\\\"cardType\\\":\\\"Spell\\\",\\\"spellType\\\":\\\"Normal\\\",\\\"effectKey\\\":\\\"GOLDSARCOPHAGUS\\\",\\\"text\\\":\\\"(1)：デッキからカード１枚を選んで除外する。このカードの発動後２回目の自分スタンバイフェイズに、この効果で除外したカードを手札に加える。\\\"},\\\"HandDestruction\\\":{\\\"imageFileName\\\":\\\"HandDestruction.jpg\\\",\\\"ID\\\":\\\"72892473\\\",\\\"cardName\\\":\\\"HandDestruction\\\",\\\"cardNameJP\\\":\\\"手札抹殺\\\",\\\"cardType\\\":\\\"Spell\\\",\\\"spellType\\\":\\\"Normal\\\",\\\"effectKey\\\":\\\"HANDDESTRUCTION\\\",\\\"text\\\":\\\"(1)：手札があるプレイヤーは、その手札を全て捨てる。その後、それぞれ自身が捨てた枚数分デッキからドローする。\\\"},\\\"HiddenArmory\\\":{\\\"imageFileName\\\":\\\"HiddenArmory.jpg\\\",\\\"ID\\\":\\\"52105192\\\",\\\"cardName\\\":\\\"HiddenArmory\\\",\\\"cardNameJP\\\":\\\"アームズ・ホール\\\",\\\"cardType\\\":\\\"Spell\\\",\\\"spellType\\\":\\\"Normal\\\",\\\"effectKey\\\":\\\"HIDDENARMORY\\\",\\\"text\\\":\\\"このカードを発動するターン、自分は通常召喚できない。(1)：デッキの一番上のカードを墓地へ送って発動できる。自分のデッキ・墓地から装備魔法カード１枚を選んで手札に加える。\\\"},\\\"Hurricane\\\":{\\\"imageFileName\\\":\\\"Hurricane.jpg\\\",\\\"ID\\\":\\\"68167124\\\",\\\"cardName\\\":\\\"Hurricane\\\",\\\"cardNameJP\\\":\\\"ハリケーン\\\",\\\"cardType\\\":\\\"Spell\\\",\\\"spellType\\\":\\\"Normal\\\",\\\"effectKey\\\":\\\"HURRICANE\\\",\\\"text\\\":\\\"フィールド上の魔法・罠カードを全て持ち主の手札に戻す。\\\"},\\\"MagicStoneExcavation\\\":{\\\"imageFileName\\\":\\\"MagicStoneExcavation.jpg\\\",\\\"ID\\\":\\\"98494543\\\",\\\"cardName\\\":\\\"MagicStoneExcavation\\\",\\\"cardNameJP\\\":\\\"魔法石の採掘\\\",\\\"cardType\\\":\\\"Spell\\\",\\\"spellType\\\":\\\"Normal\\\",\\\"effectKey\\\":\\\"MAGICSTONEEXCAVATION\\\",\\\"text\\\":\\\"(1)：手札を２枚捨て、自分の墓地の魔法カード１枚を対象として発動できる。そのカードを手札に加える。\\\"},\\\"MonsterGate\\\":{\\\"imageFileName\\\":\\\"MonsterGate.jpg\\\",\\\"ID\\\":\\\"43040603\\\",\\\"cardName\\\":\\\"MonsterGate\\\",\\\"cardNameJP\\\":\\\"モンスターゲート\\\",\\\"cardType\\\":\\\"Spell\\\",\\\"spellType\\\":\\\"Normal\\\",\\\"effectKey\\\":\\\"MONSTERGATE\\\",\\\"text\\\":\\\"(1)：自分フィールドのモンスター１体をリリースして発動できる。通常召喚可能なモンスターが出るまで自分のデッキの上からカードをめくり、そのモンスターを特殊召喚する。残りのめくったカードは全て墓地へ送る。\\\"},\\\"MonsterReborn\\\":{\\\"imageFileName\\\":\\\"MonsterReborn.jpg\\\",\\\"ID\\\":\\\"83764718\\\",\\\"cardName\\\":\\\"MonsterReborn\\\",\\\"cardNameJP\\\":\\\"死者蘇生\\\",\\\"cardType\\\":\\\"Spell\\\",\\\"spellType\\\":\\\"Normal\\\",\\\"effectKey\\\":\\\"MONSTERREBORN\\\",\\\"text\\\":\\\"(1)：自分または相手の墓地のモンスター１体を対象として発動できる。そのモンスターを自分フィールドに特殊召喚する。\\\"},\\\"PhenixBlade\\\":{\\\"imageFileName\\\":\\\"PhenixBlade.jpg\\\",\\\"ID\\\":\\\"31423101\\\",\\\"cardName\\\":\\\"PhenixBlade\\\",\\\"cardNameJP\\\":\\\"神剣-フェニックス・ブレード\\\",\\\"cardType\\\":\\\"Spell\\\",\\\"spellType\\\":\\\"Equip\\\",\\\"effectKey\\\":\\\"PHENIXBLADE\\\",\\\"text\\\":\\\"戦士族モンスターにのみ装備可能。装備モンスターの攻撃力は３００ポイントアップする。自分のメインフェイズ時、自分の墓地に存在する戦士族モンスター２体をゲームから除外する事で、このカードを自分の墓地から手札に加える。\\\"},\\\"PrematureBrial\\\":{\\\"imageFileName\\\":\\\"PrematureBrial.jpg\\\",\\\"ID\\\":\\\"70828912\\\",\\\"cardName\\\":\\\"PrematureBrial\\\",\\\"cardNameJP\\\":\\\"早すぎた埋葬\\\",\\\"cardType\\\":\\\"Spell\\\",\\\"spellType\\\":\\\"Equip\\\",\\\"effectKey\\\":\\\"PREMATUREBRIAL\\\",\\\"text\\\":\\\"８００ライフポイントを払い、自分の墓地に存在するモンスター１体を選択して発動する。選択したモンスターを表側攻撃表示で特殊召喚し、このカードを装備する。このカードが破壊された時、装備モンスターを破壊する。\\\"},\\\"Reasoning\\\":{\\\"imageFileName\\\":\\\"Reasoning.jpg\\\",\\\"ID\\\":\\\"58577036\\\",\\\"cardName\\\":\\\"Reasoning\\\",\\\"cardNameJP\\\":\\\"名推理\\\",\\\"cardType\\\":\\\"Spell\\\",\\\"spellType\\\":\\\"Normal\\\",\\\"effectKey\\\":\\\"REASONING\\\",\\\"text\\\":\\\"(1)：相手は１～１２までの任意のレベルを宣言する。通常召喚可能なモンスターが出るまで自分のデッキの上からカードをめくり、そのモンスターのレベルが宣言されたレベルと同じ場合、めくったカードを全て墓地へ送る。違った場合、そのモンスターを特殊召喚し、残りのめくったカードは全て墓地へ送る。\\\"},\\\"Reinforcement\\\":{\\\"imageFileName\\\":\\\"Reinforcement.jpg\\\",\\\"ID\\\":\\\"32807846\\\",\\\"cardName\\\":\\\"Reinforcement\\\",\\\"cardNameJP\\\":\\\"増援\\\",\\\"cardType\\\":\\\"Spell\\\",\\\"spellType\\\":\\\"Normal\\\",\\\"effectKey\\\":\\\"REINFORCEMENT\\\",\\\"text\\\":\\\"(1)：デッキからレベル４以下の戦士族モンスター１体を手札に加える。\\\"},\\\"SpellEconomics\\\":{\\\"imageFileName\\\":\\\"SpellEconomics.jpg\\\",\\\"ID\\\":\\\"04259068\\\",\\\"cardName\\\":\\\"SpellEconomics\\\",\\\"cardNameJP\\\":\\\"魔力倹約術\\\",\\\"cardType\\\":\\\"Spell\\\",\\\"spellType\\\":\\\"Continuous\\\",\\\"effectKey\\\":\\\"SPELLECONOMICS\\\",\\\"text\\\":\\\"魔法カードを発動するために払うライフポイントが必要なくなる。\\\"},\\\"TradeIn\\\":{\\\"imageFileName\\\":\\\"TradeIn.jpg\\\",\\\"ID\\\":\\\"38120068\\\",\\\"cardName\\\":\\\"TradeIn\\\",\\\"cardNameJP\\\":\\\"トレード・イン\\\",\\\"cardType\\\":\\\"Spell\\\",\\\"spellType\\\":\\\"Normal\\\",\\\"effectKey\\\":\\\"TRADEIN\\\",\\\"text\\\":\\\"(1)：手札からレベル８モンスター１体を捨てて発動できる。自分はデッキから２枚ドローする。\\\"},\\\"MagicalExplosion\\\":{\\\"imageFileName\\\":\\\"MagicalExplosion.jpg\\\",\\\"ID\\\":\\\"32723153\\\",\\\"cardName\\\":\\\"MagicalExplosion\\\",\\\"cardNameJP\\\":\\\"マジカル・エクスプロージョン\\\",\\\"cardType\\\":\\\"Trap\\\",\\\"trapType\\\":\\\"Normal\\\",\\\"effectKey\\\":\\\"MAGICALEXPLOSION\\\",\\\"text\\\":\\\"自分の手札が０枚の時に発動する事ができる。自分の墓地に存在する魔法カードの枚数×２００ポイントダメージを相手ライフに与える。\\\"}}\");\n\n//# sourceURL=webpack:///./src/CardStatus.json?");

/***/ }),

/***/ "./src/createButton.ts":
/*!*****************************!*\
  !*** ./src/createButton.ts ***!
  \*****************************/
/*! exports provided: createButton */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createButton\", function() { return createButton; });\nfunction createButton(text, width, height, keyColor) {\n    // ボタン要素をグループ化\n    var button = new createjs.Container();\n    button.name = text; // ボタンに参考までに名称を入れておく(必須ではない)\n    button.cursor = \"pointer\"; // ホバー時にカーソルを変更する\n    // 通常時の座布団を作成\n    var bgUp = new createjs.Shape();\n    bgUp.graphics\n        .setStrokeStyle(1.0)\n        .beginStroke(keyColor)\n        .beginFill(\"white\")\n        .drawRoundRect(0.5, 0.5, width - 1.0, height - 1.0, 20);\n    button.addChild(bgUp);\n    bgUp.visible = true; // 表示する\n    // ロールオーバー時の座布団を作成\n    var bgOver = new createjs.Shape();\n    bgOver.graphics\n        .beginFill(keyColor)\n        .drawRoundRect(0, 0, width, height, 20);\n    bgOver.visible = false; // 非表示にする\n    button.addChild(bgOver);\n    // ラベルを作成\n    var label = new createjs.Text(text, \"18px sans-serif\", keyColor);\n    label.x = width / 2;\n    label.y = height / 2;\n    label.textAlign = \"center\";\n    label.textBaseline = \"middle\";\n    button.addChild(label);\n    // ロールオーバーイベントを登録\n    button.addEventListener(\"mouseover\", handleMouseOver);\n    button.addEventListener(\"mouseout\", handleMouseOut);\n    function handleMouseOver(event) {\n        bgUp.visible = false;\n        bgOver.visible = true;\n        label.color = \"white\";\n    }\n    function handleMouseOut(event) {\n        bgUp.visible = true;\n        bgOver.visible = false;\n        label.color = keyColor;\n    }\n    return button;\n}\n\n\n//# sourceURL=webpack:///./src/createButton.ts?");

/***/ }),

/***/ "./src/createTextButton.ts":
/*!*********************************!*\
  !*** ./src/createTextButton.ts ***!
  \*********************************/
/*! exports provided: createTextButton */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createTextButton\", function() { return createTextButton; });\nfunction createTextButton(text, font, keyColor, shadowColor) {\n    const button = new createjs.Container();\n    button.name = text;\n    button.cursor = \"pointer\";\n    // ラベル\n    const label = new createjs.Text(text, font, keyColor);\n    label.textAlign = \"center\";\n    label.textBaseline = \"middle\";\n    label.x = label.getMeasuredWidth() / 2;\n    label.y = label.getMeasuredHeight() / 2;\n    // 透明背景\n    const bg = new createjs.Shape();\n    bg.graphics\n        .beginFill(\"white\")\n        .drawRoundRect(0, 0, label.getMeasuredWidth(), label.getMeasuredHeight(), 10);\n    bg.alpha = 0.01;\n    button.addChild(label);\n    button.addChild(bg);\n    button.regX = label.getMeasuredWidth() / 2;\n    button.regY = label.getMeasuredHeight() / 2;\n    button.addEventListener(\"mouseover\", handleMouseOverStart);\n    button.addEventListener(\"mouseout\", handleMouseOutStart);\n    function handleMouseOverStart(event) {\n        label.shadow = new createjs.Shadow(shadowColor, 0, 0, 20);\n    }\n    ;\n    function handleMouseOutStart(event) {\n        label.shadow = null;\n    }\n    ;\n    return button;\n}\n\n\n//# sourceURL=webpack:///./src/createTextButton.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _createButton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createButton */ \"./src/createButton.ts\");\n/* harmony import */ var _createTextButton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createTextButton */ \"./src/createTextButton.ts\");\n/* harmony import */ var _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CardStatus.json */ \"./src/CardStatus.json\");\nvar _CardStatus_json__WEBPACK_IMPORTED_MODULE_2___namespace = /*#__PURE__*/__webpack_require__.t(/*! ./CardStatus.json */ \"./src/CardStatus.json\", 1);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nconst DEFAULT_LIFE = 8000;\nconst cardImgSize = { x: 123, y: 180, margin: 10 };\nconst windowSize = { w: cardImgSize.x * 7, h: cardImgSize.y + 20 };\nlet selectedCardImgArray = [];\nclass Grid {\n    constructor(front, back) {\n        this.front = front;\n        this.back = back;\n    }\n}\n;\nclass Game {\n    constructor() {\n        this.defaultDeck = [];\n        this.FIELD = [undefined];\n        this.MO = [undefined, undefined, undefined, undefined, undefined];\n        this.ST = [undefined, undefined, undefined, undefined, undefined];\n        this.GY = [];\n        this.DD = [];\n        this.EXTRA = [];\n        this.HAND = [];\n        this.DECK = [];\n        this.myLifePoint = DEFAULT_LIFE;\n        this.enemyLifePoint = DEFAULT_LIFE;\n        this.normalSummon = true;\n        this.countNS = 0;\n        this.payLPcost = true;\n        this.chain = [];\n        this.nowTime = new Time;\n        this.timeArray = [];\n        const front_position = (() => {\n            const array = [];\n            for (let i = 0; i < 8; i++) {\n                if (i < 7) {\n                    array.push([cardImgSize.x / 2 + 20 + (cardImgSize.y + cardImgSize.margin) * i, cardImgSize.y / 2 + 20 + 100]);\n                }\n                else if (i == 7) {\n                    array.push([cardImgSize.x / 2 - 20 + (cardImgSize.y + cardImgSize.margin) * i, cardImgSize.y / 2 + 20 + 100]);\n                }\n                ;\n            }\n            ;\n            return array;\n        })();\n        const back_position = (() => {\n            const array = [];\n            for (let i = 8; i < 15; i++) {\n                array.push([cardImgSize.x / 2 + 20 + (cardImgSize.y + cardImgSize.margin) * (i - 8), cardImgSize.y * 1.5 + 40 + 100]);\n            }\n            ;\n            return array;\n        })();\n        this.grid = new Grid(front_position, back_position);\n        this.displayOrder = {\n            field: [this.grid.front[0]],\n            mon: [this.grid.front[3], this.grid.front[2], this.grid.front[4], this.grid.front[1], this.grid.front[5]],\n            gy: [this.grid.front[6]],\n            dd: [this.grid.front[7]],\n            ex: [this.grid.back[0]],\n            st: [this.grid.back[3], this.grid.back[2], this.grid.back[4], this.grid.back[1], this.grid.back[5]],\n            deck: [this.grid.back[6]],\n            hand: [this.grid.front[3][0], this.grid.front[3][1] * 3]\n        };\n        this.centerGrid = { x: this.grid.front[3][0], y: (this.grid.front[0][1] + this.grid.back[0][1]) / 2 };\n    }\n    ;\n}\n;\nclass Time {\n    constructor() {\n        this.summon = [];\n        this.move = [];\n        this.leaveBoard = [];\n        this.discard = [];\n        this.destroy = [];\n        this.vanish = [];\n        this.release = [];\n        this.bounce = [];\n        this.effectActived = [];\n    }\n    ;\n}\n;\n;\nclass Card {\n    constructor() {\n        this.cardBackImageFileName = \"cardback.jpeg\";\n        this.location = \"DECK\";\n        this.face = \"UP\";\n        this.effect = [];\n        this.canDestroy = true;\n        this.canVanish = true;\n        this.equipMark = [];\n        this.button = (() => {\n            const NSButton = new button(this, \"NS\", cardImgSize.x, 40, \"#0275d8\");\n            const SSButton = new button(this, \"SS\", cardImgSize.x, 40, \"#0275d8\");\n            const SETButton = new button(this, \"SET\", cardImgSize.x, 40, \"#0275d8\");\n            const ACTIVATEButton = new button(this, \"ACTIVATE\", cardImgSize.x, 40, \"#0275d8\");\n            const FLIPButton = new button(this, \"FLIP\", cardImgSize.x, 40, \"#0275d8\");\n            const VIEWButton = new button(this, \"VIEW\", cardImgSize.x, 40, \"#0275d8\");\n            return { NS: NSButton, SS: SSButton, SET: SETButton, ACTIVATE: ACTIVATEButton, FLIP: FLIPButton, VIEW: VIEWButton };\n        })();\n    }\n    ;\n}\n;\nclass MonsterCard extends Card {\n    constructor() {\n        super();\n        this.cardType = \"Monster\";\n        this.canNS = true;\n        this.buff = [];\n        this.equip = [];\n        this.RuleSScondition = () => { return false; };\n    }\n    ;\n}\n;\nclass SpellCard extends Card {\n    constructor() {\n        super();\n        this.cardType = \"Spell\";\n        this.peggingTarget = [];\n    }\n    ;\n}\n;\nclass TrapCard extends Card {\n    constructor() {\n        super();\n        this.cardType = \"Trap\";\n        this.peggingTarget = [];\n    }\n    ;\n}\n;\nclass effect {\n    constructor(card) {\n        this.card = card;\n        this.targetCard = [];\n        this.costCard = [];\n        this.mode = true;\n        this.lifeCost = 0;\n    }\n    ;\n}\n;\nclass button {\n    constructor(card, text, w, h, color) {\n        this.card = card;\n        this.buttonContainer = Object(_createButton__WEBPACK_IMPORTED_MODULE_0__[\"createButton\"])(text, w, h, color);\n    }\n    ;\n}\n;\nconst timeout = (ms) => {\n    return new Promise(resolve => setTimeout(resolve, ms));\n};\nconst zerofix = (num) => {\n    if (num <= 0) {\n        return \"0\";\n    }\n    else {\n        return num.toFixed();\n    }\n    ;\n};\nconst genCenterText = (text) => {\n    const newText = new createjs.Text(text, \"80px serif\", \"midnightblue\");\n    newText.textBaseline = \"middle\";\n    newText.textAlign = \"center\";\n    return newText;\n};\nconst genCardObject = {\n    Monster: (json) => {\n        const newCard = new MonsterCard;\n        Object.keys(json).map((key, index, array) => {\n            newCard[key] = json[key];\n        });\n        return newCard;\n    },\n    Spell: (json) => {\n        const newCard = new SpellCard;\n        Object.keys(json).map((key, index, array) => {\n            newCard[key] = json[key];\n        });\n        return newCard;\n    },\n    Trap: (json) => {\n        const newCard = new TrapCard;\n        Object.keys(json).map((key, index, array) => {\n            newCard[key] = json[key];\n        });\n        return newCard;\n    },\n};\n/**\n * 公開 非公開領域判定\n */\nconst publicOrPrivate = (card) => {\n    const PublicArea = [\"MO\", \"ST\", \"FIELD\", \"GY\", \"DD\"];\n    if (PublicArea.includes(card.location)) {\n        return \"Public\";\n    }\n    else {\n        return \"Private\";\n    }\n    ;\n};\nwindow.onload = function () {\n    /**\n     * 指定のstageに指定のcardを指定座標で描画する\n     *\n     * @param container ステージ\n     * @param card\n     * @param x 座標\n     * @param y 座標\n     */\n    function puton(container, card, x, y) {\n        card.imgContainer = new createjs.Container();\n        container.addChild(card.imgContainer);\n        card.imgContainer.cursor = \"pointer\";\n        card.frontImg = new createjs.Bitmap(card.imageFileName);\n        card.imgContainer.addChild(card.frontImg);\n        card.frontImg.regX = cardImgSize.x / 2;\n        card.frontImg.regY = cardImgSize.y / 2;\n        card.frontImg.scaleX = 0;\n        card.cardBackImg = new createjs.Bitmap(card.cardBackImageFileName);\n        card.imgContainer.addChild(card.cardBackImg);\n        card.cardBackImg.regX = cardImgSize.x / 2;\n        card.cardBackImg.regY = cardImgSize.y / 2;\n        card.imgContainer.regX = 0;\n        card.imgContainer.regY = 0;\n        [card.imgContainer.x, card.imgContainer.y] = [x, y];\n        Object.values(card.button).forEach(b => {\n            card.imgContainer.addChild(b.buttonContainer);\n            b.buttonContainer.visible = false;\n        });\n    }\n    ;\n    /**\n     * ボードのカード置き場の枠を描画する\n     */\n    const setBoard = (stage) => {\n        const drawzone = (x, y, i) => {\n            let zone = new createjs.Shape();\n            zone.graphics.beginStroke(\"#0055bb\");\n            zone.graphics.drawRect((cardImgSize.y - cardImgSize.x) / 2, 0, cardImgSize.x, cardImgSize.y);\n            if ((1 <= i && i <= 5)) {\n                zone.graphics.drawRect(0, (cardImgSize.y - cardImgSize.x) / 2, cardImgSize.y, cardImgSize.x);\n            }\n            ;\n            stage.addChild(zone);\n            zone.regX = cardImgSize.y / 2;\n            zone.regY = cardImgSize.y / 2;\n            zone.x = x;\n            zone.y = y;\n        };\n        for (let i = 0; i < 15; i++) {\n            const target = (() => {\n                if (i < 8) {\n                    return game.grid.front[i];\n                }\n                else {\n                    return game.grid.back[i - 8];\n                }\n                ;\n            })();\n            drawzone(target[0], target[1], i);\n        }\n        ;\n    };\n    /**\n     * 発動するカードを選択する\n     */\n    const selectActivateCard = (effArray, cancel) => {\n        const tmpCard = new Card;\n        const tmpEff = new effect(tmpCard);\n        return new Promise((resolve, reject) => {\n            const cardlist = effArray.flatMap(eff => eff.card);\n            openCardListWindow.select(cardlist, 1, 1, tmpEff, \"発動する効果を選択してください\", cancel);\n            SelectOkButton.addEventListener(\"click\", clickOkButton);\n            function clickOkButton(e) {\n                divSelectMenuContainer.style.visibility = \"hidden\";\n                disprayStage.removeAllChildren();\n                resolve(tmpEff.targetCard.pop());\n            }\n            ;\n            SelectCancelButton.addEventListener(\"click\", clickCancelButton);\n            function clickCancelButton(e) {\n                divSelectMenuContainer.style.visibility = \"hidden\";\n                disprayStage.removeAllChildren();\n                resolve();\n            }\n            ;\n        });\n    };\n    /**\n     * 永続ルールチェック\n     */\n    const ContinuousEffect = (time) => __awaiter(this, void 0, void 0, function* () {\n        const boardUp = genCardArray({ location: [\"MO\", \"ST\", \"GY\"], face: [\"UP\"] });\n        const AllCoRu = (() => {\n            const tmpCoArray = [];\n            boardUp.map((card, index, array) => {\n                tmpCoArray.push(...(card.effect.filter(eff => eff.effType == \"Continuous\" || eff.effType == \"Rule\")));\n            });\n            return tmpCoArray;\n        })();\n        const canActiveEffects = (EffArray, time) => {\n            return EffArray.filter(eff => eff.actionPossible(time));\n        };\n        yield (() => __awaiter(this, void 0, void 0, function* () {\n            for (let eff of canActiveEffects(AllCoRu, time)) {\n                yield eff.apply();\n            }\n            ;\n        }))();\n    });\n    /**\n     * 誘発、クイックエフェクトをチェック\n     */\n    const TriggerQuickeEffect = () => __awaiter(this, void 0, void 0, function* () {\n        cardContainer.mouseEnabled = false;\n        const canActiveEffects = (EffArray, time) => {\n            return EffArray.filter(eff => time.map(t => eff.actionPossible(t))\n                .includes(true));\n        };\n        do {\n            const AllTrigger = (() => {\n                const tmpTriggerArray = [];\n                [...game.defaultDeck].map((card, index, array) => {\n                    tmpTriggerArray.push(...(card.effect.filter(eff => eff.effType == \"Trigger\")));\n                });\n                return tmpTriggerArray;\n            })();\n            const TriggerObj = (() => {\n                const TriggerPublicForced = AllTrigger.filter(eff => eff.whetherToActivate == \"Forced\" &&\n                    publicOrPrivate(eff.card) == \"Public\");\n                const TriggerPublicAny = AllTrigger.filter(eff => eff.whetherToActivate == \"Any\" &&\n                    publicOrPrivate(eff.card) == \"Public\");\n                const TriggerPrivateForced = AllTrigger.filter(eff => eff.whetherToActivate == \"Forced\" &&\n                    publicOrPrivate(eff.card) == \"Private\");\n                const TriggerPrivateAny = AllTrigger.filter(eff => eff.whetherToActivate == \"Any\" &&\n                    publicOrPrivate(eff.card) == \"Private\");\n                return {\n                    \"PublicForced\": TriggerPublicForced,\n                    \"PublicAny\": TriggerPublicAny,\n                    \"PrivateForced\": TriggerPrivateForced,\n                    \"PrivateAny\": TriggerPrivateAny\n                };\n            })();\n            const TriggerTime = [...game.timeArray];\n            game.timeArray = [];\n            do {\n                const PubForced = canActiveEffects(TriggerObj.PublicForced, TriggerTime);\n                if (PubForced.length > 1) {\n                    const activeEffOrg = (yield selectActivateCard(PubForced)).effect.filter(eff => eff.effType == \"Trigger\" && canActiveEffects([eff], TriggerTime)).pop();\n                    const result = Object.assign(Object.assign({}, activeEffOrg), { targetCard: [], costCard: [] });\n                    game.nowTime = new Time;\n                    game.nowTime.effectActived.push({\n                        card: result.card,\n                        eff: result\n                    });\n                    yield animationChainEffectActivate(result);\n                    yield result.whenActive(result);\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    game.chain.push(result);\n                    TriggerObj.PublicForced = TriggerObj.PublicForced.filter(eff => eff !== activeEffOrg);\n                }\n                else if (PubForced.length == 1) {\n                    const activeEffOrg = PubForced.pop();\n                    const result = Object.assign(Object.assign({}, activeEffOrg), { targetCard: [], costCard: [] });\n                    game.nowTime = new Time;\n                    game.nowTime.effectActived.push({\n                        card: result.card,\n                        eff: result\n                    });\n                    yield animationChainEffectActivate(result);\n                    yield result.whenActive(result);\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    game.chain.push(result);\n                    TriggerObj.PublicForced = TriggerObj.PublicForced.filter(eff => eff !== activeEffOrg);\n                }\n                ;\n            } while (canActiveEffects(TriggerObj.PublicForced, TriggerTime).length > 0);\n            do {\n                const PubAny = canActiveEffects(TriggerObj.PublicAny, TriggerTime);\n                if (PubAny.length > 1) {\n                    const selectedCard = yield selectActivateCard(PubAny, true);\n                    if (selectedCard) {\n                        const activeEffOrg = selectedCard.effect.filter(eff => eff.effType == \"Trigger\" && canActiveEffects([eff], TriggerTime)).pop();\n                        const result = Object.assign(Object.assign({}, activeEffOrg), { targetCard: [], costCard: [] });\n                        game.nowTime = new Time;\n                        game.nowTime.effectActived.push({\n                            card: result.card,\n                            eff: result\n                        });\n                        yield animationChainEffectActivate(result);\n                        yield result.whenActive(result);\n                        game.timeArray.push(Object.assign({}, game.nowTime));\n                        console.log(result.card.cardName + \" Effect\");\n                        game.chain.push(result);\n                        TriggerObj.PublicAny = TriggerObj.PublicAny.filter(eff => eff !== activeEffOrg);\n                    }\n                    else {\n                        TriggerObj.PublicAny = [];\n                    }\n                    ;\n                }\n                else if (PubAny.length == 1) {\n                    const activeEffOrg = PubAny.pop();\n                    if (yield (openYesNoWindow(activeEffOrg.card.cardNameJP + \"の効果を発動しますか？\"))) {\n                        const result = Object.assign(Object.assign({}, activeEffOrg), { targetCard: [], costCard: [] });\n                        game.nowTime = new Time;\n                        game.nowTime.effectActived.push({\n                            card: result.card,\n                            eff: result\n                        });\n                        yield animationChainEffectActivate(result);\n                        yield result.whenActive(result);\n                        game.timeArray.push(Object.assign({}, game.nowTime));\n                        console.log(result.card.cardName + \" Effect\");\n                        game.chain.push(result);\n                    }\n                    ;\n                    TriggerObj.PublicAny = TriggerObj.PublicAny.filter(eff => eff !== activeEffOrg);\n                }\n                ;\n            } while (canActiveEffects(TriggerObj.PublicAny, TriggerTime).length > 0);\n            // チェーン解決\n            if (game.chain.length == 0) {\n                console.log(\"NO TriggerEffect\");\n            }\n            else {\n                yield timeout(250);\n                yield (() => __awaiter(this, void 0, void 0, function* () {\n                    console.log(\"Chain resolve\");\n                    for (let eff of game.chain.reverse()) {\n                        yield animationchainResolve(eff);\n                        yield eff.whenResolve(eff);\n                    }\n                    ;\n                }))();\n                yield (() => __awaiter(this, void 0, void 0, function* () {\n                    for (let eff of game.chain) {\n                        if (eff.card instanceof SpellCard && (eff.card.spellType == \"Normal\" || eff.card.spellType == \"Quick\")) {\n                            yield moveCard.BOARD.toGY(eff.card);\n                        }\n                        ;\n                    }\n                    ;\n                }))();\n                game.chain = [];\n            }\n            ;\n        } while (game.timeArray.length != 0);\n        cardContainer.mouseEnabled = true;\n        ;\n    });\n    const genCardArray = (conditions) => {\n        let CardArray = [...game.defaultDeck];\n        for (let key in conditions) {\n            CardArray = CardArray.filter(card => key in card && (conditions[key].includes(card[key]) || [...card[key]].includes(conditions[key][0])));\n        }\n        ;\n        return CardArray;\n    };\n    const SetStatusDisprayEvent = (card, targetObj) => {\n        targetObj.addEventListener(\"mouseover\", handleMoverStatus);\n        function handleMoverStatus(event) {\n            statusStage.removeAllChildren();\n            const cardImg = new createjs.Bitmap(card.cardName + \"_view.jpg\");\n            statusStage.addChild(cardImg);\n            cardImg.setTransform(statusCanv.width / 2, statusCanv.height / 2, 1, 1, 0, 0, 0, 140, 206);\n            statusCardNameText.innerText = card.cardNameJP;\n            const typetext = (() => {\n                if (card instanceof MonsterCard) {\n                    return [\"☆\" + card.level, card.monsterType, card.attribute, card.race].join(\" / \");\n                }\n                else if (card instanceof SpellCard) {\n                    return card.spellType + \" Spell\";\n                }\n                else if (card instanceof TrapCard) {\n                    return card.trapType + \" Trap\";\n                }\n                ;\n            })();\n            statusCardTypeText.innerText = typetext;\n            statusCardEffText.innerText = card.text;\n        }\n        ;\n    };\n    /**\n     * マウスイベント設定\n     */\n    const mouseEventSetting = {\n        board: (card) => __awaiter(this, void 0, void 0, function* () {\n            card.imgContainer.removeAllEventListeners();\n            const buConArray = Object.values(card.button).map(b => b.buttonContainer);\n            buConArray.forEach(b => {\n                b.removeAllEventListeners(\"click\");\n                b.visible = false;\n            });\n            SetStatusDisprayEvent(card, card.imgContainer);\n            card.imgContainer.addEventListener(\"mouseover\", handleFieldMover);\n            function handleFieldMover(event) {\n                const disprayButtonArray = [];\n                if (canActiveEffects(card).length > 0) {\n                    disprayButtonArray.push(card.button.ACTIVATE.buttonContainer);\n                }\n                ;\n                disprayButtonArray.forEach((button, index, array) => {\n                    button.x = -cardImgSize.x / 2;\n                    button.y = cardImgSize.y / 2 - 40 * (array.length) + 40 * (index);\n                    button.visible = true;\n                });\n            }\n            ;\n            card.imgContainer.addEventListener(\"mouseout\", handleFieldMout);\n            function handleFieldMout(event) {\n                buConArray.forEach(b => { b.visible = false; });\n            }\n            ;\n            const equipMarkArray = () => {\n                if (card instanceof MonsterCard) {\n                    if (1 <= card.equip.length) {\n                        const array = card.equip.map(eq => genEquipImg(eq));\n                        array.push(genEquipImg(card));\n                        return array;\n                    }\n                    else {\n                        return [];\n                    }\n                    ;\n                }\n                else {\n                    return [];\n                }\n                ;\n            };\n            card.imgContainer.addEventListener(\"mouseover\", handleEquipTargetMover);\n            function handleEquipTargetMover(event) {\n                card.equipMark = [];\n                equipMarkArray().forEach(m => {\n                    mainstage.addChild(m);\n                    card.equipMark.push(m);\n                });\n            }\n            ;\n            card.imgContainer.addEventListener(\"mouseout\", handleFieldEquipMout);\n            function handleFieldEquipMout(event) {\n                card.equipMark.forEach(m => {\n                    mainstage.removeChild(m);\n                });\n            }\n            ;\n            card.button.ACTIVATE.buttonContainer.addEventListener(\"click\", handleActivatebuttonClick);\n            function handleActivatebuttonClick(event) {\n                if (card instanceof SpellCard) {\n                    fieldSpellActivate(card);\n                    buConArray.forEach(b => { b.removeAllEventListeners(\"click\"); });\n                }\n                else if (card instanceof MonsterCard) {\n                    BoardIgnitionActivate(card);\n                }\n                ;\n            }\n            ;\n        }),\n        HAND: (card) => __awaiter(this, void 0, void 0, function* () {\n            card.imgContainer.removeAllEventListeners();\n            const buConArray = Object.values(card.button).map(b => b.buttonContainer);\n            buConArray.forEach(b => {\n                b.removeAllEventListeners(\"click\");\n                b.visible = false;\n            });\n            SetStatusDisprayEvent(card, card.imgContainer);\n            card.imgContainer.addEventListener(\"mouseover\", handleHandMover);\n            function handleHandMover(event) {\n                const disprayButtonArray = [];\n                if (card instanceof SpellCard) {\n                    if (canActiveEffects(card).length > 0 && genCardArray({ location: [\"ST\"] }).length < 5) {\n                        disprayButtonArray.push(card.button.ACTIVATE.buttonContainer);\n                    }\n                    ;\n                }\n                else if (card instanceof MonsterCard) {\n                    if (canActiveEffects(card).length > 0) {\n                        disprayButtonArray.push(card.button.ACTIVATE.buttonContainer);\n                    }\n                    ;\n                }\n                ;\n                if (card instanceof MonsterCard && card.RuleSScondition()) {\n                    disprayButtonArray.push(card.button.SS.buttonContainer);\n                }\n                ;\n                if (card instanceof MonsterCard && JudgeNS(card)) {\n                    disprayButtonArray.push(card.button.NS.buttonContainer);\n                    disprayButtonArray.push(card.button.SET.buttonContainer);\n                }\n                else if ((card instanceof SpellCard || card instanceof TrapCard) && genCardArray({ location: [\"ST\"] }).length < 5) {\n                    disprayButtonArray.push(card.button.SET.buttonContainer);\n                }\n                ;\n                disprayButtonArray.forEach((button, index, array) => {\n                    button.x = -cardImgSize.x / 2;\n                    button.y = cardImgSize.y / 2 - 40 * (array.length) + 40 * (index);\n                    button.visible = true;\n                });\n            }\n            ;\n            card.imgContainer.addEventListener(\"mouseout\", handleHandMout);\n            function handleHandMout(event) {\n                buConArray.forEach(b => { b.visible = false; });\n            }\n            ;\n            card.button.ACTIVATE.buttonContainer.addEventListener(\"click\", handleActivatebuttonClick);\n            function handleActivatebuttonClick(event) {\n                if (card instanceof SpellCard) {\n                    handSpellActivate(card);\n                }\n                else if (card instanceof MonsterCard) {\n                    // 手札の起動効果発動\n                }\n                ;\n            }\n            ;\n            card.button.NS.buttonContainer.addEventListener(\"click\", handleNSbuttonClick);\n            function handleNSbuttonClick(event) {\n                if (card instanceof MonsterCard) {\n                    normalSummon(card, \"ATK\");\n                }\n                ;\n            }\n            ;\n            card.button.SS.buttonContainer.addEventListener(\"click\", handleSSbuttonClick);\n            function handleSSbuttonClick(event) {\n                if (card instanceof MonsterCard) {\n                    card.RuleSSpromise();\n                }\n                ;\n            }\n            ;\n            card.button.SET.buttonContainer.addEventListener(\"click\", handleSETbuttonClick);\n            function handleSETbuttonClick(event) {\n                return __awaiter(this, void 0, void 0, function* () {\n                    if (card instanceof MonsterCard) {\n                        yield normalSummon(card, \"SET\");\n                    }\n                    ;\n                    if (card instanceof SpellCard || card instanceof TrapCard) {\n                        SpellTrapSet.fromHAND(card);\n                    }\n                    ;\n                });\n            }\n            ;\n        }),\n        GY: (card) => __awaiter(this, void 0, void 0, function* () {\n            card.imgContainer.removeAllEventListeners();\n            const buConArray = Object.values(card.button).map(b => b.buttonContainer);\n            buConArray.forEach(button => {\n                button.removeAllEventListeners(\"click\");\n                button.visible = false;\n            });\n            SetStatusDisprayEvent(card, card.imgContainer);\n            card.imgContainer.addEventListener(\"mouseover\", handleFieldMover);\n            function handleFieldMover(event) {\n                const disprayButtonArray = [];\n                const canActivateGYCard = game.GY.filter(card => canActiveEffects(card).length > 0);\n                if (game.GY[game.GY.length - 1] === card) {\n                    if (canActivateGYCard.length > 0) {\n                        disprayButtonArray.push(card.button.ACTIVATE.buttonContainer);\n                    }\n                    ;\n                    disprayButtonArray.push(card.button.VIEW.buttonContainer);\n                }\n                ;\n                disprayButtonArray.forEach((button, index, array) => {\n                    button.x = -cardImgSize.x / 2;\n                    button.y = cardImgSize.y / 2 - 40 * (array.length) + 40 * (index);\n                    button.visible = true;\n                });\n            }\n            ;\n            card.imgContainer.addEventListener(\"mouseout\", handleFieldMout);\n            function handleFieldMout(event) {\n                buConArray.forEach(b => { b.visible = false; });\n            }\n            ;\n            card.button.ACTIVATE.buttonContainer.addEventListener(\"click\", handleActivatebuttonClick);\n            function handleActivatebuttonClick(event) {\n                GyEffActivate();\n                // buConArray.forEach(b =>{b.removeAllEventListeners(\"click\");});\n            }\n            ;\n            card.button.VIEW.buttonContainer.addEventListener(\"click\", handlViewbuttonClick);\n            function handlViewbuttonClick(event) {\n                openCardListWindow.view(game.GY, \"GY\");\n                const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                    divSelectMenuContainer.style.visibility = \"hidden\";\n                    disprayStage.removeAllChildren();\n                    SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                });\n                SelectOkButton.addEventListener(\"click\", clickOkButton);\n            }\n            ;\n        }),\n        DD: (card) => __awaiter(this, void 0, void 0, function* () {\n            card.imgContainer.removeAllEventListeners();\n            const buConArray = Object.values(card.button).map(b => b.buttonContainer);\n            buConArray.forEach(button => {\n                button.removeAllEventListeners(\"click\");\n                button.visible = false;\n            });\n            SetStatusDisprayEvent(card, card.imgContainer);\n            card.imgContainer.addEventListener(\"mouseover\", handleFieldMover);\n            function handleFieldMover(event) {\n                const disprayButtonArray = [];\n                const canActivateGYCard = game.DD.filter(card => canActiveEffects(card).length > 0);\n                if (game.DD[game.DD.length - 1] === card) {\n                    if (canActivateGYCard.length > 0) {\n                        disprayButtonArray.push(card.button.ACTIVATE.buttonContainer);\n                    }\n                    ;\n                    disprayButtonArray.push(card.button.VIEW.buttonContainer);\n                }\n                ;\n                disprayButtonArray.forEach((button, index, array) => {\n                    button.x = -cardImgSize.x / 2;\n                    button.y = cardImgSize.y / 2 - 40 * (array.length) + 40 * (index);\n                    button.visible = true;\n                });\n            }\n            ;\n            card.imgContainer.addEventListener(\"mouseout\", handleFieldMout);\n            function handleFieldMout(event) {\n                buConArray.forEach(b => { b.visible = false; });\n            }\n            ;\n            card.button.ACTIVATE.buttonContainer.addEventListener(\"click\", handleActivatebuttonClick);\n            function handleActivatebuttonClick(event) {\n                // 除外ゾーン効果発動\n                // buConArray.forEach(b =>{b.removeAllEventListeners(\"click\");});\n            }\n            ;\n            card.button.VIEW.buttonContainer.addEventListener(\"click\", handlViewbuttonClick);\n            function handlViewbuttonClick(event) {\n                openCardListWindow.view(game.DD, \"DD\");\n                const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                    divSelectMenuContainer.style.visibility = \"hidden\";\n                    disprayStage.removeAllChildren();\n                    SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                });\n                SelectOkButton.addEventListener(\"click\", clickOkButton);\n            }\n            ;\n        }),\n        DECK: (card) => __awaiter(this, void 0, void 0, function* () {\n            card.imgContainer.removeAllEventListeners();\n            const buConArray = Object.values(card.button).map(b => b.buttonContainer);\n            buConArray.forEach(button => {\n                button.removeAllEventListeners(\"click\");\n                button.visible = false;\n            });\n        }),\n    };\n    const LocationSetting = (card, to) => __awaiter(this, void 0, void 0, function* () {\n        if (card.location == \"MO\" || card.location == \"ST\") {\n            game[card.location][game[card.location].indexOf(card)] = void 0;\n        }\n        else {\n            game[card.location] = game[card.location].filter(n => n !== card);\n        }\n        ;\n        if (to == \"MO\" || to == \"ST\") {\n            game[to].splice(game[to].indexOf(undefined), 1, card);\n        }\n        else {\n            game[to].push(card);\n        }\n        ;\n        card.location = to;\n        if (to == \"MO\" || to == \"ST\" || to == \"FIELD\") {\n            yield mouseEventSetting.board(card);\n        }\n        else {\n            yield mouseEventSetting[to](card);\n        }\n        ;\n    });\n    /**\n     * 移動カードのanimation設定\n     */\n    const Animation = {\n        toBOARD: (card, position) => {\n            const toGrid = (() => {\n                if (card instanceof MonsterCard) {\n                    let toX = game.displayOrder.mon[game.MO.indexOf(card)][0];\n                    let toY = game.displayOrder.mon[game.MO.indexOf(card)][1];\n                    return { toX, toY };\n                }\n                else {\n                    let toX = game.displayOrder.st[game.ST.indexOf(card)][0];\n                    let toY = game.displayOrder.st[game.ST.indexOf(card)][1];\n                    return { toX, toY };\n                }\n                ;\n            })();\n            const { toX, toY } = toGrid;\n            const TWEEN = () => {\n                if (position == \"ATK\") {\n                    if (card instanceof MonsterCard) {\n                        return createjs.Tween.get(card.imgContainer)\n                            .call(() => { cardContainer.setChildIndex(card.imgContainer, cardContainer.numChildren - 1); })\n                            .to({ x: toX, y: toY, scaleX: 1.5, scaleY: 1.5 }, 400, createjs.Ease.cubicOut)\n                            .to({ scaleX: 1, scaleY: 1 }, 400, createjs.Ease.cubicIn)\n                            .wait(200);\n                    }\n                    else {\n                        return createjs.Tween.get(card.imgContainer)\n                            .call(() => { cardContainer.setChildIndex(card.imgContainer, cardContainer.numChildren - 1); })\n                            .to({ x: toX, y: toY }, 500, createjs.Ease.cubicOut);\n                    }\n                    ;\n                }\n                ;\n                if (position == \"DEF\") {\n                    if (card instanceof MonsterCard) {\n                        return createjs.Tween.get(card.imgContainer)\n                            .call(() => { cardContainer.setChildIndex(card.imgContainer, cardContainer.numChildren - 1); })\n                            .to({ x: toX, y: toY, rotation: -90, scaleX: 1.5, scaleY: 1.5 }, 400, createjs.Ease.cubicOut)\n                            .to({ scaleX: 1, scaleY: 1 }, 400, createjs.Ease.cubicIn);\n                    }\n                    ;\n                }\n                ;\n                if (position == \"SET\") {\n                    if (card instanceof MonsterCard) {\n                        return createjs.Tween.get(card.imgContainer)\n                            .call(() => { cardContainer.setChildIndex(card.imgContainer, cardContainer.numChildren - 1); })\n                            .call(() => { cardFlip(card); })\n                            .to({ x: toX, y: toY, rotation: -90 }, 500, createjs.Ease.cubicOut);\n                    }\n                    else {\n                        return createjs.Tween.get(card.imgContainer)\n                            .call(() => { cardContainer.setChildIndex(card.imgContainer, cardContainer.numChildren - 1); })\n                            .call(() => { cardFlip(card); })\n                            .to({ x: toX, y: toY }, 500, createjs.Ease.cubicOut);\n                    }\n                    ;\n                }\n                ;\n            };\n            return new Promise((resolve, reject) => {\n                TWEEN().call(() => { resolve(); });\n            });\n        },\n        toGY: (card) => {\n            const toX = game.displayOrder.gy[0][0] + (game.GY.length - 1) * 0.5;\n            const toY = game.displayOrder.gy[0][1] - (game.GY.length - 1) * 0.5;\n            return new Promise((resolve, reject) => {\n                if (card.face == \"DOWN\") {\n                    cardFlip(card);\n                }\n                ;\n                createjs.Tween.get(card.imgContainer)\n                    .call(() => { cardContainer.setChildIndex(card.imgContainer, cardContainer.numChildren - 1); })\n                    .to({ x: toX, y: toY, rotation: 0 }, 500, createjs.Ease.cubicOut)\n                    .call(() => { resolve(); });\n            });\n        },\n        fromGY: (card) => {\n            cardContainer.setChildIndex(card.imgContainer, cardContainer.numChildren - 1);\n            const PromiseArray = [];\n            game.GY.map((card, index, array) => {\n                const twPromise = () => {\n                    return new Promise((resolve, reject) => {\n                        createjs.Tween.get(card.imgContainer)\n                            .to({ x: game.displayOrder.gy[0][0] + index * 0.5, y: game.displayOrder.gy[0][1] - index * 0.5 })\n                            .call(() => { cardContainer.setChildIndex(card.imgContainer, cardContainer.numChildren - array.length + index); })\n                            .call(() => { resolve(); });\n                    });\n                };\n                PromiseArray.push(twPromise());\n            });\n            return Promise.all(PromiseArray);\n        },\n        toDD: (card) => {\n            const toX = game.displayOrder.dd[0][0] + (game.DD.length - 1) * 0.5;\n            const toY = game.displayOrder.dd[0][1] - (game.DD.length - 1) * 0.5;\n            return new Promise((resolve, reject) => {\n                if (card.face == \"DOWN\") {\n                    cardFlip(card);\n                }\n                ;\n                createjs.Tween.get(card.imgContainer)\n                    .call(() => { cardContainer.setChildIndex(card.imgContainer, cardContainer.numChildren - 1); })\n                    .to({ x: toX, y: toY, rotation: 0 }, 500, createjs.Ease.cubicOut)\n                    .call(() => { resolve(); });\n            });\n        },\n        fromDD: (card) => {\n            cardContainer.setChildIndex(card.imgContainer, cardContainer.numChildren - 1);\n            const PromiseArray = [];\n            game.DD.map((card, index, array) => {\n                const twPromise = () => {\n                    return new Promise((resolve, reject) => {\n                        createjs.Tween.get(card.imgContainer)\n                            .to({ x: game.displayOrder.dd[0][0] + index * 0.5, y: game.displayOrder.dd[0][1] - index * 0.5 })\n                            .call(() => { cardContainer.setChildIndex(card.imgContainer, cardContainer.numChildren - array.length + index); })\n                            .call(() => { resolve(); });\n                    });\n                };\n                PromiseArray.push(twPromise());\n            });\n            return Promise.all(PromiseArray);\n        },\n        toDECK: (card) => {\n            const toX = game.displayOrder.deck[0][0] + (game.DECK.length - 1) * 0.5;\n            const toY = game.displayOrder.deck[0][1] - (game.DECK.length - 1) * 0.5;\n            return new Promise((resolve, reject) => {\n                if (card.face == \"UP\") {\n                    cardFlip(card);\n                }\n                ;\n                createjs.Tween.get(card.imgContainer)\n                    .call(() => { cardContainer.setChildIndex(card.imgContainer, cardContainer.numChildren - 1); })\n                    .to({ x: toX, y: toY, rotation: 0 }, 500, createjs.Ease.cubicOut)\n                    .call(() => { resolve(); });\n            });\n        },\n    };\n    const moveCard = {\n        HAND: {\n            toBOARD: (card, position) => __awaiter(this, void 0, void 0, function* () {\n                if (card instanceof MonsterCard) {\n                    yield LocationSetting(card, \"MO\");\n                }\n                else {\n                    yield LocationSetting(card, \"ST\");\n                }\n                ;\n                yield Promise.all([animationHandAdjust(), Animation.toBOARD(card, position)]);\n            }),\n            toGY: (card) => __awaiter(this, void 0, void 0, function* () {\n                yield LocationSetting(card, \"GY\");\n                yield Promise.all([animationHandAdjust(), Animation.toGY(card)]);\n            }),\n            toDD: (card) => __awaiter(this, void 0, void 0, function* () {\n                yield LocationSetting(card, \"DD\");\n                yield Promise.all([animationHandAdjust(), Animation.toDD(card)]);\n            }),\n        },\n        DECK: {\n            toHAND: (card) => __awaiter(this, void 0, void 0, function* () {\n                yield LocationSetting(card, \"HAND\");\n                yield animationHandAdjust();\n            }),\n            toGY: (card) => __awaiter(this, void 0, void 0, function* () {\n                yield LocationSetting(card, \"GY\");\n                yield Animation.toGY(card);\n            }),\n            toBOARD: (card, position) => __awaiter(this, void 0, void 0, function* () {\n                if (card instanceof MonsterCard) {\n                    yield LocationSetting(card, \"MO\");\n                }\n                else {\n                    yield LocationSetting(card, \"ST\");\n                }\n                ;\n                yield Promise.all([Animation.toBOARD(card, position)]);\n            }),\n            toDD: (card) => __awaiter(this, void 0, void 0, function* () {\n                yield LocationSetting(card, \"DD\");\n                yield Animation.toDD(card);\n            }),\n        },\n        BOARD: {\n            toGY: (card) => __awaiter(this, void 0, void 0, function* () {\n                if ([\"ST\", \"MO\", \"FIELD\"].includes(card.location)) {\n                    yield LocationSetting(card, \"GY\");\n                    yield Animation.toGY(card);\n                }\n                ;\n            }),\n            toDD: (card) => __awaiter(this, void 0, void 0, function* () {\n                if ([\"ST\", \"MO\", \"FIELD\"].includes(card.location)) {\n                    yield LocationSetting(card, \"DD\");\n                    yield Animation.toDD(card);\n                }\n                ;\n            }),\n            toHAND: (card) => __awaiter(this, void 0, void 0, function* () {\n                yield LocationSetting(card, \"HAND\");\n                yield animationHandAdjust();\n            }),\n        },\n        GY: {\n            toBOARD: (card, position) => __awaiter(this, void 0, void 0, function* () {\n                if (card instanceof MonsterCard) {\n                    yield LocationSetting(card, \"MO\");\n                }\n                else {\n                    yield LocationSetting(card, \"ST\");\n                }\n                ;\n                // await Promise.all([Animation.fromGY(card), Animation.toBOARD(card, position)]);\n                yield Animation.toBOARD(card, position);\n                yield Animation.fromGY(card);\n            }),\n            toHAND: (card) => __awaiter(this, void 0, void 0, function* () {\n                yield LocationSetting(card, \"HAND\");\n                // await Promise.all([animationHandAdjust(),Animation.fromGY(card)]);\n                yield animationHandAdjust();\n                yield Animation.fromGY(card);\n            }),\n            toDD: (card) => __awaiter(this, void 0, void 0, function* () {\n                yield LocationSetting(card, \"DD\");\n                // await Promise.all([Animation.toDD(card),Animation.fromGY(card)]);\n                yield Animation.toDD(card);\n                yield Animation.fromGY(card);\n            }),\n            toDECK: (card) => __awaiter(this, void 0, void 0, function* () {\n                yield LocationSetting(card, \"DECK\");\n                // await Promise.all([Animation.toDECK(card),Animation.fromGY(card)]);\n                yield Animation.toDECK(card);\n                yield Animation.fromGY(card);\n            }),\n        },\n        DD: {\n            toHAND: (card) => __awaiter(this, void 0, void 0, function* () {\n                yield LocationSetting(card, \"HAND\");\n                yield animationHandAdjust();\n                yield Animation.fromDD(card);\n            }),\n            toBOARD: (card, position) => __awaiter(this, void 0, void 0, function* () {\n                if (card instanceof MonsterCard) {\n                    yield LocationSetting(card, \"MO\");\n                }\n                else {\n                    yield LocationSetting(card, \"ST\");\n                }\n                ;\n                yield Animation.toBOARD(card, position);\n                yield Animation.fromDD(card);\n            }),\n        },\n    };\n    /**\n     * チェーンに乗る効果発動アニメーション\n     */\n    const animationChainEffectActivate = (eff) => __awaiter(this, void 0, void 0, function* () {\n        const chainNumber = (chainNum, eff) => {\n            const newText = new createjs.Text(chainNum.toString(), \"100px serif\", \"DarkRed\");\n            newText.textAlign = \"center\";\n            newText.textBaseline = \"middle\";\n            newText.scaleX = 3;\n            newText.scaleY = 3;\n            newText.x = eff.card.imgContainer.x;\n            newText.y = eff.card.imgContainer.y;\n            newText.alpha = 0;\n            return newText;\n        };\n        const effImg = new createjs.Bitmap(eff.card.imageFileName);\n        effImg.regX = cardImgSize.x / 2;\n        effImg.regY = cardImgSize.y / 2;\n        effImg.x = eff.card.imgContainer.x;\n        effImg.y = eff.card.imgContainer.y;\n        mainstage.addChild(effImg);\n        const cardPromise = new Promise((resolve, reject) => {\n            createjs.Tween.get(effImg)\n                .to({ scaleX: 3, scaleY: 3, alpha: 0 }, 500, createjs.Ease.cubicOut)\n                .call(() => { mainstage.removeChild(effImg); })\n                .call(() => { resolve(); });\n        });\n        const chainPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            if (game.chain.length == 1) {\n                yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.chain[0].chainBrock = chainNumber(1, game.chain[0]);\n                    mainstage.addChild(game.chain[0].chainBrock);\n                    createjs.Tween.get(game.chain[0].chainBrock)\n                        .to({ scaleX: 1, scaleY: 1, alpha: 1 }, 500, createjs.Ease.cubicIn)\n                        .call(() => { resolve(); });\n                }));\n                yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    eff.chainBrock = chainNumber(2, eff);\n                    mainstage.addChild(eff.chainBrock);\n                    createjs.Tween.get(eff.chainBrock)\n                        .to({ scaleX: 1, scaleY: 1, alpha: 1 }, 500, createjs.Ease.cubicIn)\n                        .call(() => { resolve(); });\n                }));\n            }\n            else if (2 <= game.chain.length) {\n                yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    eff.chainBrock = chainNumber(game.chain.length + 1, eff);\n                    mainstage.addChild(eff.chainBrock);\n                    createjs.Tween.get(eff.chainBrock)\n                        .to({ scaleX: 1, scaleY: 1, alpha: 1 }, 500, createjs.Ease.cubicIn)\n                        .call(() => { resolve(); });\n                }));\n            }\n            ;\n            resolve();\n        }));\n        yield cardPromise;\n        yield chainPromise;\n        return;\n    });\n    /**\n     * チェーンブロック解決アニメーション\n     */\n    const animationchainResolve = (eff) => __awaiter(this, void 0, void 0, function* () {\n        if (eff.chainBrock) {\n            yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                createjs.Tween.get(eff.chainBrock)\n                    .to({ scaleX: 3, scaleY: 3, alpha: 0 }, 500, createjs.Ease.cubicOut)\n                    .call(() => {\n                    mainstage.removeChild(eff.chainBrock);\n                    eff.chainBrock = void (0);\n                })\n                    .call(() => { resolve(); });\n            }));\n        }\n        ;\n    });\n    /**\n     * 対象をとるアニメーション\n     */\n    const animationEffectTarget = (cardArray) => {\n        const genAimImg = () => {\n            const aimImg = new createjs.Bitmap(\"aimingMark.png\");\n            aimImg.setTransform(0, 0, 3, 3);\n            aimImg.regX = 64;\n            aimImg.regY = 64;\n            aimImg.alpha = 0;\n            createjs.Ticker.addEventListener(\"tick\", handleTick);\n            function handleTick() {\n                aimImg.rotation += 2;\n            }\n            ;\n            return aimImg;\n        };\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            yield (() => __awaiter(this, void 0, void 0, function* () {\n                for (let card of cardArray) {\n                    yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                        if (card.location == \"GY\") {\n                            game.GY.splice(game.GY.lastIndexOf(card), 1);\n                            game.GY.push(card);\n                            game.GY.map((c, index, array) => {\n                                createjs.Tween.get(c.imgContainer)\n                                    .to({ x: game.displayOrder.gy[0][0] + index * 0.5, y: game.displayOrder.gy[0][1] - index * 0.5 })\n                                    .call(() => { cardContainer.setChildIndex(c.imgContainer, cardContainer.numChildren - array.length + index); });\n                            });\n                        }\n                        else if (card.location == \"DD\") {\n                            game.DD.splice(game.DD.lastIndexOf(card), 1);\n                            game.DD.push(card);\n                            game.DD.map((c, index, array) => {\n                                createjs.Tween.get(c.imgContainer)\n                                    .to({ x: game.displayOrder.dd[0][0] + index * 0.5, y: game.displayOrder.dd[0][1] - index * 0.5 })\n                                    .call(() => { cardContainer.setChildIndex(c.imgContainer, cardContainer.numChildren - array.length + index); });\n                            });\n                        }\n                        ;\n                        const aimImg = genAimImg();\n                        card.imgContainer.addChild(aimImg);\n                        createjs.Tween.get(aimImg)\n                            .to({ scaleX: 0.8, scaleY: 0.8, alpha: 1 }, 250, createjs.Ease.cubicIn)\n                            .wait(1000)\n                            .to({ alpha: 0 }, 250)\n                            .call(() => { card.imgContainer.removeChild(aimImg); })\n                            .call(() => { resolve(); });\n                    }));\n                }\n                ;\n            }))();\n            resolve();\n        }));\n    };\n    /**\n     * 手札の魔法発動\n     */\n    const handSpellActivate = (card) => __awaiter(this, void 0, void 0, function* () {\n        cardContainer.mouseEnabled = false;\n        const Effect = card.effect.find(Eff => Eff.effType == \"CardActived\");\n        const ActivedEffect = Object.assign(Object.assign({}, Effect), { targetCard: [], costCard: [] });\n        game.nowTime = new Time;\n        yield moveCard.HAND.toBOARD(card, \"ATK\");\n        yield animationChainEffectActivate(ActivedEffect);\n        yield ActivedEffect.whenActive(ActivedEffect);\n        game.timeArray.push(Object.assign({}, game.nowTime));\n        game.chain.push(ActivedEffect);\n        yield TriggerQuickeEffect();\n        cardContainer.mouseEnabled = true;\n        return;\n    });\n    /**\n     * 墓地の起動効果発動\n     */\n    const GyEffActivate = () => __awaiter(this, void 0, void 0, function* () {\n        cardContainer.mouseEnabled = false;\n        ;\n        const AllGyIgnition = (() => {\n            const tmpArray = [];\n            game.GY.map((card, index, array) => {\n                tmpArray.push(...(card.effect.filter(eff => eff.effType == \"Ignition\" &&\n                    eff.range.includes(\"GY\"))));\n            });\n            return tmpArray;\n        })();\n        const selectedCard = yield selectActivateCard(AllGyIgnition, true);\n        if (selectedCard) {\n            const Effect = canActiveEffects(selectedCard).pop();\n            const ActivedEffect = Object.assign(Object.assign({}, Effect), { targetCard: [], costCard: [] });\n            game.nowTime = new Time;\n            yield animationChainEffectActivate(ActivedEffect);\n            yield ActivedEffect.whenActive(ActivedEffect);\n            game.timeArray.push(Object.assign({}, game.nowTime));\n            game.chain.push(ActivedEffect);\n            yield TriggerQuickeEffect();\n        }\n        ;\n        cardContainer.mouseEnabled = true;\n        return;\n    });\n    /**\n     * 場の起動効果発動\n     */\n    const BoardIgnitionActivate = (card) => __awaiter(this, void 0, void 0, function* () {\n        cardContainer.mouseEnabled = false;\n        const Effect = card.effect.find(Eff => Eff.effType == \"Ignition\");\n        const ActivedEffect = Object.assign(Object.assign({}, Effect), { targetCard: [], costCard: [] });\n        game.nowTime = new Time;\n        game.nowTime.effectActived.push({\n            card: ActivedEffect.card,\n            eff: ActivedEffect\n        });\n        yield animationChainEffectActivate(ActivedEffect);\n        yield ActivedEffect.whenActive(ActivedEffect);\n        game.timeArray.push(Object.assign({}, game.nowTime));\n        game.chain.push(ActivedEffect);\n        yield TriggerQuickeEffect();\n        cardContainer.mouseEnabled = true;\n        return;\n    });\n    /**\n     * 場の魔法発動\n     */\n    const fieldSpellActivate = (card) => __awaiter(this, void 0, void 0, function* () {\n        cardContainer.mouseEnabled = false;\n        const Effect = card.effect.find(Eff => Eff.effType == \"CardActived\");\n        const ActivedEffect = Object.assign(Object.assign({}, Effect), { targetCard: [], costCard: [] });\n        game.nowTime = new Time;\n        if (card.face == \"DOWN\") {\n            yield cardFlip(card);\n        }\n        ;\n        game.nowTime = new Time;\n        game.nowTime.effectActived.push({\n            card: ActivedEffect.card,\n            eff: ActivedEffect\n        });\n        yield animationChainEffectActivate(ActivedEffect);\n        yield ActivedEffect.whenActive(ActivedEffect);\n        game.timeArray.push(Object.assign({}, game.nowTime));\n        game.chain.push(ActivedEffect);\n        yield TriggerQuickeEffect();\n        cardContainer.mouseEnabled = true;\n        return;\n    });\n    /**\n     * 魔法罠セット\n     */\n    const SpellTrapSet = {\n        fromHAND: (card) => __awaiter(this, void 0, void 0, function* () {\n            cardContainer.mouseEnabled = false;\n            yield moveCard.HAND.toBOARD(card, \"SET\");\n            // game.timeArray.push({...game.nowTime});\n            yield TriggerQuickeEffect();\n            cardContainer.mouseEnabled = true;\n        }),\n    };\n    /**\n     * 特殊召喚する\n     */\n    const SpecialSummon = {\n        fromGY: (cardArray, posiSelect, position) => __awaiter(this, void 0, void 0, function* () {\n            yield (() => __awaiter(this, void 0, void 0, function* () {\n                for (let card of cardArray) {\n                    if (card instanceof MonsterCard) {\n                        const posi = yield (() => __awaiter(this, void 0, void 0, function* () {\n                            if (posiSelect) {\n                                return yield OpenPositionWindow(card);\n                            }\n                            else {\n                                return position;\n                            }\n                            ;\n                        }))();\n                        yield moveCard.GY.toBOARD(card, posi);\n                        card.position = posi;\n                        console.log(\"SS \" + card.cardName + \" fromGY \" + posi);\n                        console.log(\"location \" + card.location);\n                        game.nowTime.summon.push({\n                            type: \"SS\",\n                            card: card,\n                            position: posi,\n                            face: card.face,\n                            from: \"GY\"\n                        });\n                        game.nowTime.move.push({\n                            card: card,\n                            from: \"GY\",\n                            to: \"MO\"\n                        });\n                    }\n                    ;\n                }\n                ;\n            }))();\n            console.log(game.nowTime);\n            yield ContinuousEffect(game.nowTime);\n            game.timeArray.push(game.nowTime);\n            if (game.chain.length == 0) {\n                yield TriggerQuickeEffect();\n                game.timeArray.map(time => console.log(time));\n            }\n            ;\n        }),\n        fromDD: (cardArray, posiSelect, position) => __awaiter(this, void 0, void 0, function* () {\n            yield (() => __awaiter(this, void 0, void 0, function* () {\n                for (let card of cardArray) {\n                    if (card instanceof MonsterCard) {\n                        const posi = yield (() => __awaiter(this, void 0, void 0, function* () {\n                            if (posiSelect) {\n                                return yield OpenPositionWindow(card);\n                            }\n                            else {\n                                return position;\n                            }\n                            ;\n                        }))();\n                        yield moveCard.DD.toBOARD(card, posi);\n                        card.position = posi;\n                        console.log(\"SS \" + card.cardName + \" fromDD \" + posi);\n                        console.log(\"location \" + card.location);\n                        game.nowTime.summon.push({\n                            type: \"SS\",\n                            card: card,\n                            position: posi,\n                            face: card.face,\n                            from: \"DD\"\n                        });\n                        game.nowTime.move.push({\n                            card: card,\n                            from: \"DD\",\n                            to: \"MO\"\n                        });\n                    }\n                    ;\n                }\n                ;\n            }))();\n            console.log(game.nowTime);\n            yield ContinuousEffect(game.nowTime);\n            game.timeArray.push(game.nowTime);\n            if (game.chain.length == 0) {\n                yield TriggerQuickeEffect();\n                game.timeArray.map(time => console.log(time));\n            }\n            ;\n        }),\n        fromDECK: (cardArray, posiSelect, position) => __awaiter(this, void 0, void 0, function* () {\n            yield (() => __awaiter(this, void 0, void 0, function* () {\n                for (let card of cardArray) {\n                    if (card instanceof MonsterCard) {\n                        const posi = yield (() => __awaiter(this, void 0, void 0, function* () {\n                            if (posiSelect) {\n                                return yield OpenPositionWindow(card);\n                            }\n                            else {\n                                return position;\n                            }\n                            ;\n                        }))();\n                        yield moveCard.DECK.toBOARD(card, posi);\n                        card.position = posi;\n                        console.log(\"SS \" + card.cardName + \" fromDECK \" + posi);\n                        console.log(\"location \" + card.location);\n                        game.nowTime.summon.push({\n                            type: \"SS\",\n                            card: card,\n                            position: posi,\n                            face: card.face,\n                            from: \"DECK\"\n                        });\n                        game.nowTime.move.push({\n                            card: card,\n                            from: \"DECK\",\n                            to: \"MO\"\n                        });\n                    }\n                    ;\n                }\n                ;\n            }))();\n            console.log(game.nowTime);\n            yield ContinuousEffect(game.nowTime);\n            game.timeArray.push(game.nowTime);\n            if (game.chain.length == 0) {\n                yield TriggerQuickeEffect();\n                game.timeArray.map(time => console.log(time));\n            }\n            ;\n        }),\n        fromHAND: (cardArray, posiSelect, position) => __awaiter(this, void 0, void 0, function* () {\n            yield (() => __awaiter(this, void 0, void 0, function* () {\n                for (let card of cardArray) {\n                    if (card instanceof MonsterCard) {\n                        const posi = yield (() => __awaiter(this, void 0, void 0, function* () {\n                            if (posiSelect) {\n                                return yield OpenPositionWindow(card);\n                            }\n                            else {\n                                return position;\n                            }\n                            ;\n                        }))();\n                        yield moveCard.HAND.toBOARD(card, posi);\n                        card.position = posi;\n                        console.log(\"SS \" + card.cardName + \" fromHAND \" + posi);\n                        console.log(\"location \" + card.location);\n                        game.nowTime.summon.push({\n                            type: \"SS\",\n                            card: card,\n                            position: posi,\n                            face: card.face,\n                            from: \"HAND\"\n                        });\n                        game.nowTime.move.push({\n                            card: card,\n                            from: \"HAND\",\n                            to: \"MO\"\n                        });\n                    }\n                    ;\n                }\n                ;\n            }))();\n            console.log(game.nowTime);\n            yield ContinuousEffect(game.nowTime);\n            game.timeArray.push(game.nowTime);\n            if (game.chain.length == 0) {\n                yield TriggerQuickeEffect();\n                game.timeArray.map(time => console.log(time));\n            }\n            ;\n        }),\n    };\n    /**\n     * 通常召喚する\n     */\n    const normalSummon = (card, position) => __awaiter(this, void 0, void 0, function* () {\n        cardContainer.mouseEnabled = false;\n        const numberToRelease = (() => {\n            if (5 <= card.level && card.level <= 6) {\n                return 1;\n            }\n            else if (7 <= card.level) {\n                return 2;\n            }\n            else {\n                return 0;\n            }\n            ;\n        })();\n        if (5 <= card.level) {\n            const cardlist = genCardArray({ location: [\"MO\"] });\n            const tmpCard = new Card;\n            const tmpEff = new effect(tmpCard);\n            yield new Promise((resolve, reject) => {\n                openCardListWindow.select(cardlist, numberToRelease, numberToRelease, tmpEff, \"リリースするモンスターを\" + numberToRelease + \"体選択してください\");\n                const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                    console.log(\"Release \" + tmpEff.targetCard.map(({ cardName }) => cardName));\n                    divSelectMenuContainer.style.visibility = \"hidden\";\n                    disprayStage.removeAllChildren();\n                    SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                    game.nowTime = new Time;\n                    yield release(tmpEff.targetCard, \"ADVANCE\");\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                });\n                SelectOkButton.addEventListener(\"click\", clickOkButton);\n            });\n        }\n        ;\n        game.normalSummon = false;\n        game.countNS += 1;\n        card.NSed = true;\n        if (position == \"ATK\") {\n            card.position = position;\n        }\n        ;\n        if (position == \"SET\") {\n            card.position = \"DEF\";\n        }\n        ;\n        game.nowTime = new Time;\n        yield moveCard.HAND.toBOARD(card, position);\n        game.nowTime.summon.push({\n            card: card,\n            type: \"NS\",\n            position: card.position,\n            face: card.face,\n            from: \"HAND\",\n        });\n        game.nowTime.move.push({\n            card: card,\n            from: \"HAND\",\n            to: \"MO\"\n        });\n        game.timeArray.push(Object.assign({}, game.nowTime));\n        console.log(\"NS \" + position);\n        console.log(\"location \" + card.location);\n        yield ContinuousEffect(game.nowTime);\n        yield TriggerQuickeEffect();\n        cardContainer.mouseEnabled = true;\n        game.timeArray.map(time => console.log(time));\n    });\n    /**\n     * 通常召喚可能か判定する\n     */\n    const JudgeNS = (card) => {\n        const countMonster = genCardArray({ location: [\"MO\"] }).length;\n        const NSbool = (card.canNS && game.normalSummon);\n        if (card.level <= 4) {\n            if (countMonster == 5) {\n                return false;\n            }\n            else {\n                return (NSbool);\n            }\n            ;\n        }\n        else if (5 <= card.level && card.level <= 6) {\n            return (NSbool && 1 <= countMonster);\n        }\n        else {\n            return (NSbool && 2 <= countMonster);\n        }\n        ;\n    };\n    /**\n     * 魔法罠のカード発動場所判定\n     */\n    const JudgeSpellTrapActivateLoc = (card) => {\n        return card.location == \"HAND\" || (card.location == \"ST\" && card.face == \"DOWN\");\n    };\n    /**\n     * ライフコストを払う\n     */\n    const payLife = (cost) => __awaiter(this, void 0, void 0, function* () {\n        if (!game.payLPcost) {\n            return;\n        }\n        ;\n        const LPtext = new createjs.Text(\"-\" + cost, \"80px serif\", \"black\");\n        LPtext.textBaseline = \"middle\";\n        LPtext.textAlign = \"center\";\n        LPtext.x = game.grid.front[3][0];\n        LPtext.y = (game.grid.front[0][1] + game.grid.back[0][1]) / 2;\n        mainstage.addChild(LPtext);\n        yield timeout(500);\n        yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            createjs.Tween.get(LPtext)\n                .to({ alpha: 0 }, 500)\n                .call(() => { resolve(); })\n                .call(() => { mainstage.removeChild(LPtext); });\n        }));\n        createjs.Tween.get(game)\n            .to({ myLifePoint: game.myLifePoint - cost }, 1000, createjs.Ease.cubicOut);\n        return;\n    });\n    /**\n     * ダメージ\n     */\n    const dealDamage = (point) => __awaiter(this, void 0, void 0, function* () {\n        const LPtext = new createjs.Text(\"-\" + point.toFixed(), \"80px serif\", \"red\");\n        LPtext.textBaseline = \"middle\";\n        LPtext.textAlign = \"center\";\n        LPtext.x = game.grid.front[3][0];\n        LPtext.y = (game.grid.front[0][1] + game.grid.back[0][1]) / 2;\n        mainstage.addChild(LPtext);\n        yield timeout(500);\n        yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            createjs.Tween.get(LPtext)\n                .to({ alpha: 0 }, 500)\n                .call(() => { resolve(); })\n                .call(() => { mainstage.removeChild(LPtext); });\n        }));\n        createjs.Tween.get(game)\n            .to({ enemyLifePoint: game.enemyLifePoint - point }, 1000, createjs.Ease.cubicOut);\n        return;\n    });\n    /**\n     * 捨てる\n     */\n    const discard = (cardArray) => __awaiter(this, void 0, void 0, function* () {\n        yield (() => __awaiter(this, void 0, void 0, function* () {\n            for (let card of [...cardArray].reverse()) {\n                yield moveCard.HAND.toGY(card);\n                game.nowTime.discard.push({\n                    card: card\n                });\n                game.nowTime.move.push({\n                    card: card,\n                    from: \"HAND\",\n                    to: \"GY\"\n                });\n            }\n            ;\n        }))();\n        yield ContinuousEffect(game.nowTime);\n    });\n    /**\n     * 除外する\n     */\n    const vanish = (cardArray, by) => __awaiter(this, void 0, void 0, function* () {\n        yield (() => __awaiter(this, void 0, void 0, function* () {\n            for (let card of cardArray) {\n                card.canVanish = false;\n                card.canDestroy = false;\n                const from = (() => {\n                    if ([\"MO\", \"ST\", \"FIELD\"].includes(card.location)) {\n                        return \"BOARD\";\n                    }\n                    else {\n                        return card.location;\n                    }\n                })();\n                game.nowTime.vanish.push({\n                    card: card,\n                    by: by\n                });\n                yield ContinuousEffect(game.nowTime);\n                if ([\"ST\", \"MO\", \"FIELD\"].includes(card.location)) {\n                    game.nowTime.leaveBoard.push({\n                        card: card\n                    });\n                    yield ContinuousEffect(game.nowTime);\n                }\n                ;\n                game.nowTime.move.push({\n                    card: card,\n                    from: from,\n                    to: \"DD\"\n                });\n                yield moveCard[from].toDD(card);\n                console.log(\"vanish \" + card.cardName + \" by \" + by);\n                yield ContinuousEffect(game.nowTime);\n            }\n            ;\n        }))();\n        yield ContinuousEffect(game.nowTime);\n        cardArray.forEach(card => {\n            card.canVanish = true;\n            card.canDestroy = true;\n        });\n    });\n    /**\n     * デッキトップに置く\n     */\n    const returnDecktop = (cardArray) => __awaiter(this, void 0, void 0, function* () {\n        yield (() => __awaiter(this, void 0, void 0, function* () {\n            for (let card of cardArray) {\n                const from = (() => {\n                    if ([\"MO\", \"ST\", \"FIELD\"].includes(card.location)) {\n                        return \"BOARD\";\n                    }\n                    else {\n                        return card.location;\n                    }\n                })();\n                game.nowTime.move.push({\n                    card: card,\n                    from: from,\n                    to: \"DECK\"\n                });\n                if (moveCard[from].toDECK instanceof Function) {\n                    yield moveCard[from].toDECK(card);\n                }\n                ;\n            }\n            ;\n        }))();\n        yield ContinuousEffect(game.nowTime);\n    });\n    /**\n     * バウンス\n     */\n    const bounce = (cardArray, by) => __awaiter(this, void 0, void 0, function* () {\n        yield (() => __awaiter(this, void 0, void 0, function* () {\n            for (let card of cardArray) {\n                game.nowTime.bounce.push({\n                    card: card,\n                    by: by\n                });\n                yield ContinuousEffect(game.nowTime);\n                if ([\"ST\", \"MO\", \"FIELD\"].includes(card.location)) {\n                    game.nowTime.leaveBoard.push({\n                        card: card\n                    });\n                    yield ContinuousEffect(game.nowTime);\n                }\n                ;\n                if ([\"ST\", \"MO\", \"FIELD\"].includes(card.location)) {\n                    game.nowTime.move.push({\n                        card: card,\n                        from: \"BOARD\",\n                        to: \"HAND\"\n                    });\n                    yield moveCard.BOARD.toHAND(card);\n                    yield ContinuousEffect(game.nowTime);\n                }\n                ;\n            }\n            ;\n        }))();\n        yield ContinuousEffect(game.nowTime);\n    });\n    /**\n     * リリースする\n     */\n    const release = (cardArray, by) => __awaiter(this, void 0, void 0, function* () {\n        yield (() => __awaiter(this, void 0, void 0, function* () {\n            for (let card of cardArray) {\n                card.canDestroy = false;\n                game.nowTime.release.push({\n                    card: card,\n                    by: by\n                });\n                yield ContinuousEffect(game.nowTime);\n                if ([\"ST\", \"MO\", \"FIELD\"].includes(card.location)) {\n                    game.nowTime.leaveBoard.push({\n                        card: card\n                    });\n                    yield ContinuousEffect(game.nowTime);\n                }\n                ;\n                if ([\"ST\", \"MO\", \"FIELD\"].includes(card.location)) {\n                    yield moveCard.BOARD.toGY(card);\n                    game.nowTime.move.push({\n                        card: card,\n                        from: \"BOARD\",\n                        to: \"GY\"\n                    });\n                    yield ContinuousEffect(game.nowTime);\n                }\n                ;\n            }\n            ;\n        }))();\n        yield ContinuousEffect(game.nowTime);\n        cardArray.forEach(card => {\n            card.canDestroy = true;\n        });\n    });\n    /**\n     * 破壊する\n     */\n    const destroy = (cardArray, by) => __awaiter(this, void 0, void 0, function* () {\n        const destroyAnimation = (card) => {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const destroyImg = new createjs.Bitmap(\"destroy.png\");\n                destroyImg.setTransform(card.imgContainer.x, card.imgContainer.y, 0, 0);\n                destroyImg.regX = 64;\n                destroyImg.regY = 64;\n                destroyImg.mouseEnabled = false;\n                destroyImg.alpha = 0;\n                mainstage.addChild(destroyImg);\n                yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    createjs.Tween.get(destroyImg)\n                        .to({ alpha: 1, scaleX: 2, scaleY: 2 }, 250)\n                        .to({ alpha: 0 }, 250)\n                        .wait(250)\n                        .call(() => { mainstage.removeChild(destroyImg); })\n                        .call(() => { resolve(); });\n                }));\n                resolve();\n            }));\n        };\n        yield (() => __awaiter(this, void 0, void 0, function* () {\n            for (let card of cardArray) {\n                card.canDestroy = false;\n                game.nowTime.destroy.push({\n                    card: card,\n                    by: by\n                });\n                if (by == \"BATTLE\" || by == \"EFFECT\") {\n                    console.log(\"destroy \" + card.cardName + \" by \" + by);\n                }\n                else if (by == \"RULE\") {\n                    console.log(\"destroy \" + card.cardName + \" lost equip target\");\n                }\n                ;\n                if ([\"ST\", \"MO\", \"FIELD\"].includes(card.location)) {\n                    yield destroyAnimation(card);\n                    yield ContinuousEffect(game.nowTime);\n                }\n                ;\n                if ([\"ST\", \"MO\", \"FIELD\"].includes(card.location)) {\n                    game.nowTime.leaveBoard.push({\n                        card: card\n                    });\n                    yield ContinuousEffect(game.nowTime);\n                }\n                ;\n                if ([\"ST\", \"MO\", \"FIELD\"].includes(card.location)) {\n                    yield moveCard.BOARD.toGY(card);\n                    game.nowTime.move.push({\n                        card: card,\n                        from: \"BOARD\",\n                        to: \"GY\"\n                    });\n                    yield ContinuousEffect(game.nowTime);\n                }\n                ;\n            }\n            ;\n        }))();\n        yield ContinuousEffect(game.nowTime);\n        cardArray.forEach(card => {\n            card.canDestroy = true;\n        });\n    });\n    const genEquipImg = (card) => {\n        const equipImg = new createjs.Bitmap(\"equip.png\");\n        equipImg.setTransform(card.imgContainer.x, card.imgContainer.y, 0.5, 0.5);\n        equipImg.regX = 64;\n        equipImg.regY = 64;\n        equipImg.mouseEnabled = false;\n        return equipImg;\n    };\n    /**\n     * 装備する\n     */\n    const Equip = (card, eff) => __awaiter(this, void 0, void 0, function* () {\n        card.peggingTarget = eff.targetCard;\n        const targetCard = card.peggingTarget[0];\n        if (targetCard instanceof MonsterCard) {\n            targetCard.equip.push(card);\n        }\n        ;\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const equipImg = genEquipImg(card);\n                equipImg.alpha = 0;\n                mainstage.addChild(equipImg);\n                createjs.Tween.get(equipImg)\n                    .to({ alpha: 1, scaleX: 1, scaleY: 1 }, 250)\n                    .to({ x: targetCard.imgContainer.x, y: targetCard.imgContainer.y }, 500)\n                    .to({ scaleX: 0.7, scaleY: 0.7 }, 250)\n                    .wait(250)\n                    .call(() => { mainstage.removeChild(equipImg); })\n                    .call(() => { resolve(); });\n            }));\n            const equipMarkSPELL = genEquipImg(card);\n            const equipMarkMON = genEquipImg(targetCard);\n            card.imgContainer.addEventListener(\"mouseover\", handleEquipSpellMover);\n            function handleEquipSpellMover(event) {\n                if (card.peggingTarget.length > 0) {\n                    equipMarkSPELL.setTransform(card.imgContainer.x, card.imgContainer.y, 0.5, 0.5);\n                    equipMarkSPELL.regX = 64;\n                    equipMarkSPELL.regY = 64;\n                    mainstage.addChild(equipMarkSPELL);\n                    equipMarkMON.setTransform(targetCard.imgContainer.x, targetCard.imgContainer.y, 0.5, 0.5);\n                    equipMarkMON.regX = 64;\n                    equipMarkMON.regY = 64;\n                    mainstage.addChild(equipMarkMON);\n                }\n                ;\n            }\n            ;\n            card.imgContainer.addEventListener(\"mouseout\", handleEquipMout);\n            function handleEquipMout(event) {\n                if (card.peggingTarget.length > 0) {\n                    mainstage.removeChild(equipMarkSPELL);\n                    mainstage.removeChild(equipMarkMON);\n                }\n                ;\n            }\n            ;\n            resolve();\n        }));\n    });\n    /**\n     * デッキをシャッフルする\n     */\n    function deckShuffle() {\n        if (game.DECK.length <= 1) {\n            return false;\n        }\n        game.DECK = shuffle(game.DECK);\n        const PromiseArray = [];\n        game.DECK.map((card, index, array) => {\n            const twPromise = () => {\n                return new Promise((resolve, reject) => {\n                    const orgX = card.imgContainer.x;\n                    createjs.Tween.get(card.imgContainer)\n                        .wait(index * (100 / array.length))\n                        .to({ x: orgX + 100 - (200 * (index % 2)) }, 100)\n                        .to({ x: orgX - 100 + (200 * (index % 2)) }, 200)\n                        .to({ x: game.displayOrder.deck[0][0] + index * 0.5, y: game.displayOrder.deck[0][1] - index * 0.5 }, 100)\n                        .call(() => { cardContainer.setChildIndex(card.imgContainer, cardContainer.numChildren - array.length + index); })\n                        .call(() => { resolve(); });\n                });\n            };\n            PromiseArray.push(twPromise());\n        });\n        return Promise.all(PromiseArray);\n    }\n    ;\n    /**\n     * 配列をランダム化\n     */\n    const shuffle = (target) => {\n        for (let i = target.length - 1; i >= 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [target[i], target[j]] = [target[j], target[i]];\n        }\n        return target;\n    };\n    /**\n     * 表裏反転\n     */\n    const cardFlip = (card) => {\n        const front = createjs.Tween.get(card.frontImg);\n        const back = createjs.Tween.get(card.cardBackImg);\n        const close = (target) => {\n            return new Promise((resolve, reject) => {\n                target.to({ scaleX: 0.0 }, 180, createjs.Ease.cubicOut)\n                    .call(() => { resolve(); });\n            });\n        };\n        const open = (target) => {\n            return new Promise((resolve, reject) => {\n                target.to({ scaleX: 1.0 }, 320, createjs.Ease.cubicIn)\n                    .call(() => { resolve(); });\n            });\n        };\n        const PromiseArray = () => {\n            if (card.face == \"UP\") {\n                card.face = \"DOWN\";\n                return [close(front), open(back)];\n            }\n            ;\n            if (card.face == \"DOWN\") {\n                card.face = \"UP\";\n                return [close(back), open(front)];\n            }\n            ;\n        };\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            yield Promise.all(PromiseArray());\n            resolve();\n        }));\n        // return Promise.all(PromiseArray());\n    };\n    const decksetAnimation = () => __awaiter(this, void 0, void 0, function* () {\n        const randomIndex = (() => {\n            const defaultArray = [...Array(40).keys()];\n            for (let i = defaultArray.length - 1; i >= 0; i--) {\n                const j = Math.floor(Math.random() * (i + 1));\n                [defaultArray[i], defaultArray[j]] = [defaultArray[j], defaultArray[i]];\n            }\n            ;\n            return defaultArray;\n        })();\n        yield (() => __awaiter(this, void 0, void 0, function* () {\n            for (let i of randomIndex) {\n                yield LocationSetting(game.defaultDeck[i], \"DECK\");\n                new Promise((resolve, reject) => {\n                    if (game.defaultDeck[i].face == \"UP\") {\n                        cardFlip(game.defaultDeck[i]);\n                    }\n                    ;\n                    createjs.Tween.get(game.defaultDeck[i].imgContainer)\n                        .call(() => { cardContainer.setChildIndex(game.defaultDeck[i].imgContainer, cardContainer.numChildren - 1); })\n                        .to({ x: game.displayOrder.deck[0][0], y: game.displayOrder.deck[0][1], rotation: 0 }, 500, createjs.Ease.quintOut)\n                        .call(() => { resolve(); });\n                });\n                yield timeout(50);\n            }\n            ;\n        }))();\n    });\n    const lineUp = () => {\n        const reference = { x: 85 + cardImgSize.x / 2, y: 25 + cardImgSize.y / 2 };\n        game.defaultDeck.forEach((card, i, a) => {\n            if (i <= 9) {\n                puton(cardContainer, card, reference.x + ((cardImgSize.x * 0.75) * i), reference.y);\n            }\n            else if (10 <= i && i <= 19) {\n                puton(cardContainer, card, reference.x + ((cardImgSize.x * 0.75) * (i - 10)), reference.y + (cardImgSize.y + 10) * 1);\n            }\n            else if (20 <= i && i <= 29) {\n                puton(cardContainer, card, reference.x + ((cardImgSize.x * 0.75) * (i - 20)), reference.y + (cardImgSize.y + 10) * 2);\n            }\n            else if (30 <= i) {\n                puton(cardContainer, card, reference.x + ((cardImgSize.x * 0.75) * (i - 30)), reference.y + (cardImgSize.y + 10) * 3);\n            }\n            ;\n            card.frontImg.scaleX = 1;\n            card.cardBackImg.scaleX = 0;\n            SetStatusDisprayEvent(card, card.imgContainer);\n        });\n        game.DECK = [...game.defaultDeck];\n    };\n    /**\n     * 手札を現在のデータに合わせた位置に移動するアニメーション\n     * 手札出し入れの際に呼ぶやつ\n     */\n    const animationHandAdjust = () => {\n        const PromiseArray = [];\n        game.HAND.map((card, index, array) => {\n            const handPosition = (() => {\n                if (index <= 7) {\n                    const leftEndPosition = game.displayOrder.hand[0] - ((game.HAND.length - 1) - (game.HAND.length - 8) * Math.sign(Math.trunc(game.HAND.length / 8))) / 2 * (cardImgSize.x + cardImgSize.margin);\n                    return {\n                        x: leftEndPosition + (cardImgSize.x + cardImgSize.margin) * index,\n                        y: game.displayOrder.hand[1]\n                    };\n                }\n                else {\n                    const leftEndPosition = game.displayOrder.hand[0] - (game.HAND.length - 1 - 8) / 2 * (cardImgSize.x + cardImgSize.margin);\n                    return {\n                        x: leftEndPosition + ((cardImgSize.x + cardImgSize.margin) * (index - 8)),\n                        y: game.displayOrder.hand[1] + cardImgSize.y + cardImgSize.margin\n                    };\n                }\n                ;\n            })();\n            const twPromise = () => {\n                return new Promise((resolve, reject) => {\n                    createjs.Tween.get(card.imgContainer)\n                        .call(() => {\n                        if (card.face == \"DOWN\") {\n                            cardFlip(card);\n                        }\n                        ;\n                    })\n                        .to(handPosition, 500, createjs.Ease.cubicInOut)\n                        .call(() => { resolve(); });\n                });\n            };\n            PromiseArray.push(twPromise());\n        });\n        return Promise.all(PromiseArray);\n    };\n    /**\n     * デッキから任意の枚数をドローする\n     * @param count\n     */\n    const draw = (count) => {\n        // デッキ残り枚数が０だったら引けない\n        if (game.DECK.length < count) {\n            console.log(\"deck0\");\n        }\n        ;\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            yield (() => __awaiter(this, void 0, void 0, function* () {\n                for (let i = 0; i < count; i++) {\n                    const targetCard = game.DECK[game.DECK.length - 1];\n                    yield moveCard.DECK.toHAND(targetCard);\n                    console.log(\"draw\");\n                }\n                ;\n            }))();\n            resolve();\n        }));\n    };\n    /**\n     * デッキからサーチする\n     * @param count\n     */\n    const search = (target) => {\n        console.log(\"function search\");\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            yield (() => __awaiter(this, void 0, void 0, function* () {\n                for (let card of target) {\n                    if (game.DECK.includes(card)) {\n                        console.log(\"search \" + card.cardName);\n                        yield moveCard.DECK.toHAND(card);\n                    }\n                    ;\n                }\n                ;\n            }))();\n            yield deckShuffle();\n            resolve();\n        }));\n    };\n    /**\n     * チェーン1で優先権ある時発動できる効果\n     */\n    const canActiveEffects = (card) => {\n        return card.effect.filter(eff => (eff.effType == \"CardActived\" || eff.effType == \"Quick\" || eff.effType == \"Ignition\") &&\n            eff.actionPossible({}));\n    };\n    /**\n     * 装備魔法が場から離れたとき装備解除する効果\n     */\n    const equipDisEnchant = (card) => {\n        const disEnchant = new effect(card);\n        disEnchant.effType = \"Rule\";\n        disEnchant.actionPossible = (time) => {\n            const timeCondition = (() => {\n                const timeBoolArray = [];\n                time.leaveBoard.forEach(tLeave => {\n                    timeBoolArray.push(tLeave.card == card);\n                });\n                return timeBoolArray.some(value => value);\n            })();\n            const boolarray = [\n                card.peggingTarget.length > 0,\n                timeCondition\n            ];\n            return boolarray.every(value => value == true);\n        };\n        disEnchant.apply = () => {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const equiptarget = card.peggingTarget[0];\n                if (equiptarget instanceof MonsterCard) {\n                    equiptarget.buff = equiptarget.buff.filter(b => b.eff.card !== card);\n                    equiptarget.equip = equiptarget.equip.filter(e => e !== card);\n                }\n                ;\n                card.peggingTarget = [];\n                console.log(\"disenchant\");\n                resolve();\n            }));\n        };\n        return disEnchant;\n    };\n    /**\n     * 装備魔法の対象が消えたとき自身を破壊する効果\n     */\n    const equipDestroy = (card) => {\n        const EDeff = new effect(card);\n        EDeff.effType = \"Rule\";\n        EDeff.actionPossible = (time) => {\n            const timeCondition = (() => {\n                const timeBoolArray = [];\n                time.leaveBoard.forEach(tLeave => {\n                    timeBoolArray.push(card.peggingTarget.includes(tLeave.card));\n                });\n                return timeBoolArray.some(value => value);\n            })();\n            const boolarray = [\n                card.canDestroy,\n                card.peggingTarget.length == 1,\n                card.location == \"ST\",\n                card.face == \"UP\",\n                timeCondition\n            ];\n            return boolarray.every(value => value == true);\n        };\n        EDeff.apply = () => {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                if (card.location == \"ST\") {\n                    yield destroy([card], \"RULE\");\n                }\n                ;\n                card.peggingTarget = [];\n                resolve();\n            }));\n        };\n        return EDeff;\n    };\n    const SSconditionSetting = {\n        DOGMA: (card) => {\n            card.RuleSScondition = () => {\n                const boolarray = [\n                    genCardArray({ location: [\"MO\"], category: [\"D-HERO\"] }).length >= 1,\n                    genCardArray({ location: [\"MO\"] }).length >= 3\n                ];\n                return boolarray.every(value => value == true);\n            };\n            card.RuleSSpromise = () => __awaiter(this, void 0, void 0, function* () {\n                const tmpEffA = new effect(new Card);\n                yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    const cardlistA = genCardArray({ location: [\"MO\"], category: [\"D-HERO\"] });\n                    const clickOkButtonA = (e) => __awaiter(this, void 0, void 0, function* () {\n                        divSelectMenuContainer.style.visibility = \"hidden\";\n                        disprayStage.removeAllChildren();\n                        SelectOkButton.removeEventListener(\"click\", clickOkButtonA);\n                        resolve();\n                    });\n                    SelectOkButton.addEventListener(\"click\", clickOkButtonA);\n                    yield openCardListWindow.select(cardlistA, 1, 1, tmpEffA, \"リリースするD-HEROを\" + 1 + \"体選択してください\");\n                }));\n                const tmpEffB = new effect(new Card);\n                yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    const cardlistB = genCardArray({ location: [\"MO\"] }).filter(card => !(tmpEffA.targetCard.includes(card)));\n                    const clickOkButtonB = (e) => __awaiter(this, void 0, void 0, function* () {\n                        const releaseArray = tmpEffB.targetCard.concat(tmpEffA.targetCard);\n                        console.log(\"Release \" + releaseArray.map(({ cardName }) => cardName));\n                        divSelectMenuContainer.style.visibility = \"hidden\";\n                        disprayStage.removeAllChildren();\n                        SelectOkButton.removeEventListener(\"click\", clickOkButtonB);\n                        game.nowTime = new Time;\n                        yield release(releaseArray, \"COST\");\n                        game.timeArray.push(Object.assign({}, game.nowTime));\n                        resolve();\n                    });\n                    SelectOkButton.addEventListener(\"click\", clickOkButtonB);\n                    yield openCardListWindow.select(cardlistB, 2, 2, tmpEffB, \"リリースするモンスターを\" + 2 + \"体選択してください\");\n                }));\n                yield SpecialSummon.fromHAND([card], true);\n            });\n        },\n    };\n    const shadPhase = (phase) => __awaiter(this, void 0, void 0, function* () {\n        const phaseText = genCenterText(phase);\n        phaseText.shadow = new createjs.Shadow(\"#ffffff\", 0, 0, 10);\n        phaseText.x = -200;\n        phaseText.y = game.centerGrid.y;\n        mainstage.addChild(phaseText);\n        yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            createjs.Tween.get(phaseText)\n                .to({ x: game.centerGrid.x }, 250, createjs.Ease.cubicOut)\n                .wait(750)\n                .to({ x: 1800 }, 250, createjs.Ease.cubicOut)\n                .call(() => { resolve(); })\n                .call(() => { mainstage.removeChild(phaseText); });\n        }));\n    });\n    const gameStart = () => __awaiter(this, void 0, void 0, function* () {\n        cardContainer.mouseEnabled = false;\n        ;\n        yield decksetAnimation();\n        yield timeout(500);\n        yield deckShuffle();\n        yield draw(5);\n        [myLP, EnemyLP, numOfcardsContainer, resetButton, endButton].forEach(obj => {\n            createjs.Tween.get(obj)\n                .to({ alpha: 1 }, 250);\n        });\n        yield shadPhase(\"DRAW PHASE\");\n        yield draw(1);\n        game.firstHand = [...game.HAND].map(c => c.cardNameJP);\n        yield shadPhase(\"STANBY PHASE\");\n        yield shadPhase(\"MAIN PHASE\");\n        cardContainer.mouseEnabled = true;\n    });\n    const gameEnd = () => __awaiter(this, void 0, void 0, function* () {\n        cardContainer.mouseEnabled = false;\n        ;\n        const dogmaArray = genCardArray({ ID: [\"17132130\"], location: [\"MO\"], face: [\"UP\"] });\n        const magiexArray = genCardArray({ ID: [\"32723153\"], location: [\"ST\"], face: [\"DOWN\"] });\n        yield shadPhase(\"TURN END\");\n        yield timeout(500);\n        yield (() => __awaiter(this, void 0, void 0, function* () {\n            for (let i = 0; i < dogmaArray.length; i++) {\n                yield animationChainEffectActivate(dogmaArray[i].effect[0]);\n                yield dogmaArray[i].effect[0].whenResolve(dogmaArray[i].effect[0]);\n                yield timeout(500);\n            }\n            ;\n        }))();\n        if (1 <= magiexArray.length) {\n            if (genCardArray({ location: [\"HAND\"] }).length == 0) {\n                yield (() => __awaiter(this, void 0, void 0, function* () {\n                    for (let i = 0; i < magiexArray.length; i++) {\n                        if (game.enemyLifePoint <= 0) {\n                            yield cardFlip(magiexArray[i]);\n                            yield animationChainEffectActivate(magiexArray[i].effect[0]);\n                            yield magiexArray[i].effect[0].whenResolve(magiexArray[i].effect[0]);\n                            yield moveCard.BOARD.toGY(magiexArray[i]);\n                        }\n                        ;\n                    }\n                    ;\n                }))();\n            }\n            else {\n                yield openMessageWindow(\"手札が0枚でない為、MagicalExplosionを発動できません。\");\n            }\n            ;\n            yield timeout(500);\n        }\n        ;\n        const winLose = (() => {\n            if (game.enemyLifePoint <= 0) {\n                return genCenterText(\"YOU WIN !\");\n            }\n            else {\n                return genCenterText(\"YOU LOSE\");\n            }\n            ;\n        })();\n        winLose.shadow = new createjs.Shadow(\"#000000\", 0, 0, 10);\n        winLose.x = game.centerGrid.x;\n        winLose.y = game.centerGrid.y;\n        winLose.font = \"100px serif\";\n        openResultWindow(winLose);\n    });\n    const reset = () => __awaiter(this, void 0, void 0, function* () {\n        cardContainer.mouseEnabled = false;\n        ;\n        game.countNS = 0;\n        game.normalSummon = true;\n        game.myLifePoint = DEFAULT_LIFE;\n        game.enemyLifePoint = DEFAULT_LIFE;\n        game.payLPcost = true;\n        const returnCardArray = genCardArray({ location: [\"HAND\", \"MO\", \"ST\", \"FIELD\", \"GY\", \"DD\"] });\n        const randomIndex = (() => {\n            const defaultArray = [...Array(returnCardArray.length).keys()];\n            for (let i = returnCardArray.length - 1; i >= 0; i--) {\n                const j = Math.floor(Math.random() * (i + 1));\n                [defaultArray[i], defaultArray[j]] = [defaultArray[j], defaultArray[i]];\n            }\n            ;\n            return defaultArray;\n        })();\n        yield (() => __awaiter(this, void 0, void 0, function* () {\n            for (let i of randomIndex) {\n                yield LocationSetting(returnCardArray[i], \"DECK\");\n                new Promise((resolve, reject) => {\n                    const card = returnCardArray[i];\n                    if (card instanceof MonsterCard && 1 <= card.equip.length) {\n                        card.equip = [];\n                    }\n                    ;\n                    if (card instanceof SpellCard && 1 <= card.peggingTarget.length) {\n                        card.peggingTarget = [];\n                    }\n                    ;\n                    if (returnCardArray[i].face == \"UP\") {\n                        cardFlip(returnCardArray[i]);\n                    }\n                    ;\n                    createjs.Tween.get(returnCardArray[i].imgContainer)\n                        .call(() => { cardContainer.setChildIndex(returnCardArray[i].imgContainer, cardContainer.numChildren - 1); })\n                        .to({ x: game.displayOrder.deck[0][0], y: game.displayOrder.deck[0][1], rotation: 0 }, 500, createjs.Ease.quintOut)\n                        .call(() => { resolve(); });\n                });\n                yield timeout(50);\n            }\n            ;\n        }))();\n        yield timeout(250);\n        yield deckShuffle();\n        yield draw(5);\n        yield shadPhase(\"DRAW PHASE\");\n        yield draw(1);\n        game.firstHand = [...game.HAND].map(c => c.cardNameJP);\n        yield shadPhase(\"STANBY PHASE\");\n        yield shadPhase(\"MAIN PHASE\");\n        cardContainer.mouseEnabled = true;\n        ;\n    });\n    ;\n    const effectSetting = {\n        AIRMAN: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"Trigger\";\n            eff1.whetherToActivate = \"Any\";\n            eff1.range = [\"MO\"];\n            eff1.actionPossible = (time) => {\n                const timeCondition = (() => {\n                    const timeBoolArray = [];\n                    time.summon.forEach(ts => {\n                        timeBoolArray.push([\n                            ts.type == \"NS\" || ts.type == \"SS\",\n                            ts.card == card,\n                            ts.face == \"UP\",\n                        ].every(value => value));\n                    });\n                    return timeBoolArray.some(value => value);\n                })();\n                const boolarray = [\n                    timeCondition,\n                    eff1.range.includes(card.location),\n                    genCardArray({ category: [\"HERO\"], location: [\"DECK\"] }).length > 0\n                ];\n                return boolarray.every(value => value);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    resolve();\n                });\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    if (genCardArray({ category: [\"HERO\"], location: [\"DECK\"] }).length > 0) {\n                        yield new Promise((resolve, reject) => {\n                            const cardlist = genCardArray({ category: [\"HERO\"], location: [\"DECK\"] });\n                            openCardListWindow.select(cardlist, 1, 1, eff, \"手札に加えるHEROを選択してください\");\n                            SelectOkButton.addEventListener(\"click\", clickOkButton);\n                            function clickOkButton(e) {\n                                divSelectMenuContainer.style.visibility = \"hidden\";\n                                disprayStage.removeAllChildren();\n                                SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                                resolve();\n                            }\n                            ;\n                        });\n                        yield search(eff.targetCard);\n                    }\n                    ;\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1];\n        },\n        DISK: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"Trigger\";\n            eff1.whetherToActivate = \"Forced\";\n            eff1.range = [\"MO\"];\n            eff1.actionPossible = (time) => {\n                const timeCondition = (() => {\n                    const timeBoolArray = [];\n                    time.summon.forEach(ts => {\n                        timeBoolArray.push([\n                            ts.type == \"SS\",\n                            ts.from == \"GY\",\n                            ts.card == card,\n                            ts.face == \"UP\",\n                        ].every(value => value));\n                    });\n                    return timeBoolArray.some(value => value);\n                })();\n                const boolarray = [\n                    timeCondition,\n                    eff1.range.includes(card.location),\n                ];\n                return boolarray.every(value => value);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    resolve();\n                });\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    if (2 <= game.DECK.length) {\n                        yield draw(2);\n                    }\n                    else {\n                        yield draw(game.DECK.length);\n                    }\n                    ;\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1];\n        },\n        DOGMA: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"Trigger\";\n            eff1.whetherToActivate = \"Forced\";\n            eff1.range = [\"MO\"];\n            eff1.actionPossible = (time) => {\n                return false;\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    resolve();\n                });\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    const damage = game.enemyLifePoint / 2;\n                    yield dealDamage(damage);\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1];\n        },\n        KURAZ: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"Trigger\";\n            eff1.whetherToActivate = \"Any\";\n            eff1.range = [\"MO\"];\n            eff1.actionPossible = (time) => {\n                const timeCondition = (() => {\n                    const timeBoolArray = [];\n                    time.summon.forEach(ts => {\n                        timeBoolArray.push([\n                            ts.type == \"NS\" || ts.type == \"SS\",\n                            ts.card == card,\n                            ts.face == \"UP\",\n                        ].every(value => value));\n                    });\n                    return timeBoolArray.some(value => value);\n                })();\n                const boolarray = [\n                    timeCondition,\n                    eff1.range.includes(card.location),\n                    genCardArray({ location: [\"MO\", \"ST\", \"FIELD\"] }).length > 0,\n                    genCardArray({ location: [\"DECK\"] }).length > 0\n                ];\n                return boolarray.every(value => value);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    const cardlist = genCardArray({ location: [\"MO\", \"ST\", \"FIELD\"] });\n                    const selectmax = (() => {\n                        if (game.DECK.length >= 2) {\n                            return 2;\n                        }\n                        else {\n                            return 1;\n                        }\n                        ;\n                    })();\n                    openCardListWindow.select(cardlist, 1, selectmax, eff, \"破壊するカードを選択してください\");\n                    SelectOkButton.addEventListener(\"click\", clickOkButton);\n                    function clickOkButton(e) {\n                        return __awaiter(this, void 0, void 0, function* () {\n                            divSelectMenuContainer.style.visibility = \"hidden\";\n                            disprayStage.removeAllChildren();\n                            SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                            yield animationEffectTarget(eff.targetCard);\n                            resolve();\n                        });\n                    }\n                    ;\n                });\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    const targetLocation = [\"ST\", \"MO\", \"FIELD\"];\n                    const target = eff.targetCard.filter(card => targetLocation.includes(card.location));\n                    yield destroy(target, \"EFFECT\");\n                    yield draw(target.length);\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1];\n        },\n        CYBERVARY: (card) => {\n            const eff1 = new effect(card);\n            const conditionA = () => {\n                return (genCardArray({ location: [\"MO\"] }).length >= 2 && game.DECK.length >= 2);\n            };\n            const conditionB = () => {\n                return (game.HAND.length >= 1 && genCardArray({ location: [\"GY\"], cardType: [\"Spell\"] }).length >= 1);\n            };\n            eff1.effType = \"Ignition\";\n            eff1.range = [\"MO\"];\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    eff1.range.includes(card.location),\n                    card.face == \"UP\",\n                    (conditionA() || conditionB())\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    if (conditionA() && conditionB()) {\n                        eff.mode = yield OpenSelectEffectWindow(card, `このカードと他のモンスター1体を\n除外し2枚ドローする`, `このカードと手札1枚を除外し\n墓地のカードをデッキトップに置く`);\n                    }\n                    else if (conditionA()) {\n                        eff.mode = true;\n                    }\n                    else {\n                        eff.mode = false;\n                    }\n                    ;\n                    if (eff.mode) {\n                        const cardlist = genCardArray({ location: [\"MO\"] }).filter(c => c != card);\n                        openCardListWindow.select(cardlist, 1, 1, eff, \"除外するモンスターを1枚選択してください\");\n                        const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                            divSelectMenuContainer.style.visibility = \"hidden\";\n                            disprayStage.removeAllChildren();\n                            SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                            eff.targetCard.push(card);\n                            yield animationEffectTarget(eff.targetCard);\n                            resolve();\n                        });\n                        SelectOkButton.addEventListener(\"click\", clickOkButton);\n                    }\n                    else {\n                        const cardlist = genCardArray({ location: [\"GY\"] });\n                        openCardListWindow.select(cardlist, 1, 1, eff, \"デッキトップに置くカードを\" + 1 + \"枚選択してください\");\n                        const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                            divSelectMenuContainer.style.visibility = \"hidden\";\n                            disprayStage.removeAllChildren();\n                            SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                            resolve();\n                        });\n                        SelectOkButton.addEventListener(\"click\", clickOkButton);\n                    }\n                    ;\n                }));\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    if (eff.mode) {\n                        yield vanish(eff.targetCard, \"EFFECT\");\n                        game.timeArray.push(Object.assign({}, game.nowTime));\n                        game.nowTime = new Time;\n                        yield draw(2);\n                        game.timeArray.push(Object.assign({}, game.nowTime));\n                        resolve();\n                    }\n                    else {\n                        const tmpEff = new effect(new Card);\n                        yield new Promise((resolve, reject) => {\n                            openCardListWindow.select(game.HAND, 1, 1, tmpEff, \"除外する手札を1枚選択してください\");\n                            SelectOkButton.addEventListener(\"click\", clickOkButton);\n                            function clickOkButton(e) {\n                                tmpEff.targetCard.push(card);\n                                divSelectMenuContainer.style.visibility = \"hidden\";\n                                disprayStage.removeAllChildren();\n                                SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                                resolve();\n                            }\n                            ;\n                        });\n                        yield vanish(tmpEff.targetCard, \"EFFECT\");\n                        game.timeArray.push(Object.assign({}, game.nowTime));\n                        game.nowTime = new Time;\n                        yield returnDecktop(eff.targetCard);\n                        yield cardFlip(eff.targetCard[0]);\n                        yield timeout(500);\n                        yield cardFlip(eff.targetCard[0]);\n                        game.timeArray.push(Object.assign({}, game.nowTime));\n                        resolve();\n                    }\n                    ;\n                }));\n            };\n            return [eff1];\n        },\n        MAGICIANOFCHAOS: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"Trigger\";\n            eff1.whetherToActivate = \"Any\";\n            eff1.range = [\"MO\"];\n            eff1.actionPossible = (time) => {\n                const timeCondition = (() => {\n                    const timeBoolArray = [];\n                    time.summon.forEach(ts => {\n                        timeBoolArray.push([\n                            ts.type == \"NS\" || ts.type == \"SS\",\n                            ts.card == card,\n                            ts.face == \"UP\",\n                        ].every(value => value));\n                    });\n                    return timeBoolArray.some(value => value);\n                })();\n                const boolarray = [\n                    timeCondition,\n                    eff1.range.includes(card.location),\n                    genCardArray({ cardType: [\"Spell\"], location: [\"GY\"] }).length > 0\n                ];\n                return boolarray.every(value => value);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    const cardlist = game.GY.filter(card => card instanceof SpellCard);\n                    openCardListWindow.select(cardlist, 1, 1, eff, \"手札に加える魔法を1枚選択してください\");\n                    const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                        divSelectMenuContainer.style.visibility = \"hidden\";\n                        disprayStage.removeAllChildren();\n                        SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                        yield animationEffectTarget(eff.targetCard);\n                        resolve();\n                    });\n                    SelectOkButton.addEventListener(\"click\", clickOkButton);\n                });\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    if (eff.targetCard[0].location == \"GY\") {\n                        yield moveCard.GY.toHAND(eff.targetCard[0]);\n                        game.nowTime.move.push({\n                            card: eff.targetCard[0],\n                            from: \"GY\",\n                            to: \"HAND\"\n                        });\n                        yield ContinuousEffect(game.nowTime);\n                    }\n                    ;\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            const eff2 = new effect(card);\n            eff2.effType = \"Continuous\";\n            eff2.actionPossible = (time) => {\n                const timeCondition = (() => {\n                    const timeBoolArray = [];\n                    time.destroy.forEach(tDestroy => {\n                        timeBoolArray.push(tDestroy.card == card);\n                    });\n                    time.release.forEach(tRelease => {\n                        timeBoolArray.push(tRelease.card == card);\n                    });\n                    return timeBoolArray.some(value => value);\n                })();\n                const boolarray = [\n                    card.face == \"UP\",\n                    card.canVanish,\n                    timeCondition\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff2.apply = () => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    yield vanish([card], \"EFFECT\");\n                    resolve();\n                }));\n            };\n            return [eff1, eff2];\n        },\n        REINFORCEMENT: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    JudgeSpellTrapActivateLoc(card),\n                    genCardArray({ race: [\"WARRIOR\"], location: [\"DECK\"] })\n                        .filter(card => card instanceof MonsterCard && card.level <= 4).length > 0\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    resolve();\n                });\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    const cardlist = genCardArray({ race: [\"WARRIOR\"], location: [\"DECK\"] })\n                        .filter(card => card instanceof MonsterCard && card.level <= 4);\n                    if (cardlist.length > 0) {\n                        yield new Promise((resolve, reject) => {\n                            openCardListWindow.select(cardlist, 1, 1, eff, \"手札に加えるカードを選択してください\");\n                            SelectOkButton.addEventListener(\"click\", clickOkButton);\n                            function clickOkButton(e) {\n                                divSelectMenuContainer.style.visibility = \"hidden\";\n                                disprayStage.removeAllChildren();\n                                SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                                resolve();\n                            }\n                            ;\n                        });\n                        yield search(eff.targetCard);\n                    }\n                    ;\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1];\n        },\n        DESTINYDRAW: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    JudgeSpellTrapActivateLoc(card),\n                    genCardArray({ category: [\"D-HERO\"], location: [\"HAND\"] }).length > 0\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    const cardlist = genCardArray({ category: [\"D-HERO\"], location: [\"HAND\"] });\n                    openCardListWindow.select(cardlist, 1, 1, eff, \"捨てるD-HEROを1枚選択してください\");\n                    const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                        console.log(\"cost \" + eff.targetCard.map(({ cardName }) => cardName));\n                        divSelectMenuContainer.style.visibility = \"hidden\";\n                        disprayStage.removeAllChildren();\n                        yield discard(eff.targetCard);\n                        SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                        resolve();\n                    });\n                    SelectOkButton.addEventListener(\"click\", clickOkButton);\n                });\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    yield draw(2);\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1];\n        },\n        MONSTERREBORN: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    JudgeSpellTrapActivateLoc(card),\n                    genCardArray({ location: [\"MO\"] }).length < 5,\n                    game.GY.filter(card => card instanceof MonsterCard && card.canNS).length > 0\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    const cardlist = game.GY.filter(card => card instanceof MonsterCard && card.canNS);\n                    openCardListWindow.select(cardlist, 1, 1, eff, \"特殊召喚するモンスターを1枚選択してください\");\n                    const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                        divSelectMenuContainer.style.visibility = \"hidden\";\n                        disprayStage.removeAllChildren();\n                        SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                        yield animationEffectTarget(eff.targetCard);\n                        resolve();\n                    });\n                    SelectOkButton.addEventListener(\"click\", clickOkButton);\n                });\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    const targetarray = eff.targetCard.filter(card => card.location == \"GY\");\n                    game.nowTime = new Time;\n                    yield SpecialSummon.fromGY(targetarray.reverse(), true);\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1];\n        },\n        PREMATUREBRIAL: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.lifeCost = 800;\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    (game.myLifePoint > eff1.lifeCost || !(game.payLPcost)),\n                    JudgeSpellTrapActivateLoc(card),\n                    genCardArray({ location: [\"MO\"] }).length < 5,\n                    game.GY.filter(card => card instanceof MonsterCard && card.canNS).length > 0\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    const cardlist = game.GY.filter(card => card instanceof MonsterCard && card.canNS);\n                    yield payLife(eff.lifeCost);\n                    openCardListWindow.select(cardlist, 1, 1, eff, \"特殊召喚するモンスターを1枚選択してください\");\n                    const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                        divSelectMenuContainer.style.visibility = \"hidden\";\n                        disprayStage.removeAllChildren();\n                        SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                        yield animationEffectTarget(eff.targetCard);\n                        resolve();\n                    });\n                    SelectOkButton.addEventListener(\"click\", clickOkButton);\n                }));\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    if (eff.targetCard[0].location == \"GY\" && eff.card.location == \"ST\" && eff.card.face == \"UP\") {\n                        yield SpecialSummon.fromGY(eff.targetCard, false, \"ATK\");\n                        yield Equip(card, eff);\n                    }\n                    ;\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            const eff2 = new effect(card);\n            eff2.effType = \"Continuous\";\n            eff2.actionPossible = (time) => {\n                const timeCondition = (() => {\n                    const timeBoolArray = [];\n                    time.destroy.forEach(tDestroy => {\n                        timeBoolArray.push(tDestroy.card == card);\n                    });\n                    return timeBoolArray.some(value => value);\n                })();\n                const boolarray = [\n                    card.peggingTarget.filter(card => card.canDestroy).length > 0,\n                    timeCondition\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff2.apply = () => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    if (card.peggingTarget[0].location == \"MO\") {\n                        yield destroy(card.peggingTarget, \"EFFECT\");\n                    }\n                    ;\n                    card.peggingTarget = [];\n                    resolve();\n                }));\n            };\n            return [eff1, eff2, equipDestroy(card), equipDisEnchant(card)];\n        },\n        MONSTERGATE: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    JudgeSpellTrapActivateLoc(card),\n                    game.DECK.filter(card => card instanceof MonsterCard && card.canNS).length > 0,\n                    genCardArray({ location: [\"MO\"] }).length > 0\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    const cardlist = genCardArray({ location: [\"MO\"] });\n                    openCardListWindow.select(cardlist, 1, 1, eff, \"リリースするモンスターを1枚選択してください\");\n                    const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                        console.log(\"cost \" + eff.targetCard.map(({ cardName }) => cardName));\n                        divSelectMenuContainer.style.visibility = \"hidden\";\n                        disprayStage.removeAllChildren();\n                        yield release(eff.targetCard, \"COST\");\n                        SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                        resolve();\n                    });\n                    SelectOkButton.addEventListener(\"click\", clickOkButton);\n                });\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    const decktop = () => { return game.DECK[game.DECK.length - 1]; };\n                    if (game.DECK.filter(card => card instanceof MonsterCard && card.canNS).length > 0) {\n                        yield (() => __awaiter(this, void 0, void 0, function* () {\n                            while (true) {\n                                const topcard = game.DECK[game.DECK.length - 1];\n                                yield cardFlip(topcard);\n                                yield timeout(250);\n                                if (topcard instanceof MonsterCard && topcard.canNS) {\n                                    break;\n                                }\n                                else {\n                                    console.log(\"send \" + topcard.cardName + \" to GY\");\n                                    yield moveCard.DECK.toGY(topcard);\n                                    game.nowTime.move.push({\n                                        card: topcard,\n                                        from: \"DECK\",\n                                        to: \"GY\"\n                                    });\n                                }\n                                ;\n                            }\n                            ;\n                        }))();\n                        if (decktop() instanceof MonsterCard) {\n                            yield SpecialSummon.fromDECK([decktop()], true);\n                        }\n                        ;\n                    }\n                    ;\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1];\n        },\n        PHENIXBLADE: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    JudgeSpellTrapActivateLoc(card),\n                    genCardArray({ face: [\"UP\"], location: [\"MO\"], race: [\"WARRIOR\"] }).length > 0\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    const cardlist = genCardArray({ face: [\"UP\"], location: [\"MO\"], race: [\"WARRIOR\"] });\n                    openCardListWindow.select(cardlist, 1, 1, eff, \"装備対象を選択してください\");\n                    const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                        divSelectMenuContainer.style.visibility = \"hidden\";\n                        disprayStage.removeAllChildren();\n                        SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                        yield animationEffectTarget(eff.targetCard);\n                        resolve();\n                    });\n                    SelectOkButton.addEventListener(\"click\", clickOkButton);\n                });\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    if (eff.targetCard[0].location == \"MO\" && eff.targetCard[0].face == \"UP\" && eff.card.location == \"ST\" && eff.card.face == \"UP\") {\n                        yield Equip(card, eff);\n                        const equiptarget = card.peggingTarget[0];\n                        if (equiptarget instanceof MonsterCard) {\n                            equiptarget.buff.push({ eff: eff, atkBuff: 300, defBuff: 0 });\n                        }\n                        ;\n                    }\n                    ;\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            const eff2 = new effect(card);\n            eff2.effType = \"Ignition\";\n            eff2.range = [\"GY\"];\n            eff2.actionPossible = (time) => {\n                const boolarray = [\n                    eff2.range.includes(card.location),\n                    genCardArray({ race: [\"WARRIOR\"], location: [\"GY\"] }).length >= 2\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff2.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    const cardlist = genCardArray({ race: [\"WARRIOR\"], location: [\"GY\"] });\n                    openCardListWindow.select(cardlist, 2, 2, eff, \"除外する戦士族を2枚選択してください\");\n                    const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                        console.log(\"cost \" + eff.targetCard.map(({ cardName }) => cardName));\n                        divSelectMenuContainer.style.visibility = \"hidden\";\n                        disprayStage.removeAllChildren();\n                        yield vanish(eff.targetCard, \"COST\");\n                        SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                        resolve();\n                    });\n                    SelectOkButton.addEventListener(\"click\", clickOkButton);\n                });\n            };\n            eff2.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    if (eff.card.location == \"GY\") {\n                        yield (() => __awaiter(this, void 0, void 0, function* () {\n                            yield moveCard.GY.toHAND(eff.card);\n                            game.nowTime.move.push({\n                                card: eff.card,\n                                from: \"GY\",\n                                to: \"HAND\"\n                            });\n                        }))();\n                        yield ContinuousEffect(game.nowTime);\n                    }\n                    ;\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1, eff2, equipDestroy(card), equipDisEnchant(card)];\n        },\n        DIMENSIONFUSION: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.lifeCost = 2000;\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    (game.myLifePoint > eff1.lifeCost || !(game.payLPcost)),\n                    JudgeSpellTrapActivateLoc(card),\n                    genCardArray({ location: [\"MO\"] }).length < 5,\n                    game.DD.filter(card => card instanceof MonsterCard && card.canNS).length > 0\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    yield payLife(eff.lifeCost);\n                    resolve();\n                }));\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    const blankMonsterZone = 5 - genCardArray({ location: [\"MO\"] }).length;\n                    const canNSmonster = game.DD.filter(card => card instanceof MonsterCard && card.canNS);\n                    if (canNSmonster.length > 0 && blankMonsterZone > 0) {\n                        if (canNSmonster.length > blankMonsterZone) {\n                            yield new Promise((resolve, reject) => {\n                                openCardListWindow.select(canNSmonster, blankMonsterZone, blankMonsterZone, eff, \"特殊召喚するモンスターを選択してください\");\n                                const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                                    divSelectMenuContainer.style.visibility = \"hidden\";\n                                    disprayStage.removeAllChildren();\n                                    SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                                    resolve();\n                                });\n                                SelectOkButton.addEventListener(\"click\", clickOkButton);\n                            });\n                        }\n                        else {\n                            eff.targetCard = canNSmonster;\n                        }\n                        ;\n                        yield SpecialSummon.fromDD(eff.targetCard, true);\n                    }\n                    ;\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1];\n        },\n        REASONING: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    JudgeSpellTrapActivateLoc(card),\n                    game.DECK.filter(card => card instanceof MonsterCard && card.canNS).length > 0\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    resolve();\n                });\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    const pubZone = genCardArray({ location: [\"MO\", \"GY\", \"DD\"] });\n                    const decrearLevel = (() => {\n                        if (pubZone.filter(c => c.cardName == _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"MagicianOfChaos\"].cardName).length == 0) {\n                            return 8;\n                        }\n                        else if (pubZone.filter(c => c.cardName == _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"Airman\"].cardName).length == 0) {\n                            return 4;\n                        }\n                        else if (pubZone.filter(c => c.cardName == _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"Kuraz\"].cardName).length == 0) {\n                            return 6;\n                        }\n                        else {\n                            return 1;\n                        }\n                        ;\n                    })();\n                    const decktop = () => { return game.DECK[game.DECK.length - 1]; };\n                    if (game.DECK.filter(card => card instanceof MonsterCard && card.canNS).length > 0) {\n                        yield openMessageWindow(decrearLevel + \" が宣言されました\");\n                        yield (() => __awaiter(this, void 0, void 0, function* () {\n                            while (true) {\n                                const topcard = game.DECK[game.DECK.length - 1];\n                                yield cardFlip(topcard);\n                                yield timeout(250);\n                                if (topcard instanceof MonsterCard && topcard.canNS) {\n                                    break;\n                                }\n                                else {\n                                    console.log(\"send \" + topcard.cardName + \" to GY\");\n                                    yield moveCard.DECK.toGY(topcard);\n                                    game.nowTime.move.push({\n                                        card: topcard,\n                                        from: \"DECK\",\n                                        to: \"GY\"\n                                    });\n                                }\n                                ;\n                            }\n                            ;\n                        }))();\n                        if (decktop() instanceof MonsterCard) {\n                            const top = decktop();\n                            if (top instanceof MonsterCard && top.level != decrearLevel) {\n                                yield SpecialSummon.fromDECK([decktop()], true);\n                            }\n                            else {\n                                yield moveCard.DECK.toGY(top);\n                                console.log(\"send \" + top.cardName + \" to GY\");\n                                game.nowTime.move.push({\n                                    card: top,\n                                    from: \"DECK\",\n                                    to: \"GY\"\n                                });\n                            }\n                            ;\n                        }\n                        ;\n                    }\n                    ;\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1];\n        },\n        DDR: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    game.HAND.filter(c => c != card).length > 0,\n                    JudgeSpellTrapActivateLoc(card),\n                    genCardArray({ location: [\"MO\"] }).length < 5,\n                    game.DD.filter(card => card instanceof MonsterCard && card.canNS).length > 0\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    const cardlist = game.DD.filter(card => card instanceof MonsterCard && card.canNS);\n                    yield new Promise((resolve, reject) => {\n                        openCardListWindow.select(game.HAND, 1, 1, eff, \"捨てる手札を1枚選択してください\");\n                        const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                            console.log(\"cost \" + eff.targetCard.map(({ cardName }) => cardName));\n                            divSelectMenuContainer.style.visibility = \"hidden\";\n                            disprayStage.removeAllChildren();\n                            yield discard(eff.targetCard);\n                            SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                            resolve();\n                        });\n                        SelectOkButton.addEventListener(\"click\", clickOkButton);\n                    });\n                    openCardListWindow.select(cardlist, 1, 1, eff, \"特殊召喚するモンスターを1枚選択してください\");\n                    const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                        divSelectMenuContainer.style.visibility = \"hidden\";\n                        disprayStage.removeAllChildren();\n                        SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                        yield animationEffectTarget(eff.targetCard);\n                        resolve();\n                    });\n                    SelectOkButton.addEventListener(\"click\", clickOkButton);\n                }));\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    if (eff.targetCard[0].location == \"DD\" && eff.card.location == \"ST\" && eff.card.face == \"UP\") {\n                        yield SpecialSummon.fromDD(eff.targetCard, false, \"ATK\");\n                        yield Equip(card, eff);\n                    }\n                    ;\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            const eff2 = new effect(card);\n            eff2.effType = \"Continuous\";\n            eff2.actionPossible = (time) => {\n                const timeCondition = (() => {\n                    const timeBoolArray = [];\n                    time.leaveBoard.forEach(tLeave => {\n                        timeBoolArray.push([\n                            tLeave.card == card\n                        ].every(value => value));\n                    });\n                    return timeBoolArray.some(value => value);\n                })();\n                const boolarray = [\n                    card.peggingTarget.filter(card => card.canDestroy).length > 0,\n                    timeCondition\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff2.apply = () => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    if (card.peggingTarget[0].location == \"MO\") {\n                        yield destroy(card.peggingTarget, \"EFFECT\");\n                    }\n                    ;\n                    card.peggingTarget = [];\n                    resolve();\n                }));\n            };\n            return [eff1, eff2, equipDestroy(card), equipDisEnchant(card)];\n        },\n        TRADEIN: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    JudgeSpellTrapActivateLoc(card),\n                    game.HAND.filter(c => c instanceof MonsterCard && c.level == 8).length > 0\n                    // genCardArray({level:[8],location:[\"HAND\"]}).length > 0\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    // const cardlist = genCardArray({level:[8],location:[\"HAND\"]});\n                    const cardlist = game.HAND.filter(c => c instanceof MonsterCard && c.level == 8);\n                    openCardListWindow.select(cardlist, 1, 1, eff, \"捨てるカードを1枚選択してください\");\n                    const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                        console.log(\"cost \" + eff.targetCard.map(({ cardName }) => cardName));\n                        divSelectMenuContainer.style.visibility = \"hidden\";\n                        disprayStage.removeAllChildren();\n                        yield discard(eff.targetCard);\n                        SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                        resolve();\n                    });\n                    SelectOkButton.addEventListener(\"click\", clickOkButton);\n                });\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    yield draw(2);\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1];\n        },\n        MAGICSTONEEXCAVATION: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    game.HAND.filter(c => c != card).length >= 2,\n                    JudgeSpellTrapActivateLoc(card),\n                    genCardArray({ location: [\"GY\"], cardType: [\"Spell\"] }).length >= 1\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    yield new Promise((resolve, reject) => {\n                        openCardListWindow.select(game.HAND, 2, 2, eff, \"捨てるカードを2枚選択してください\");\n                        const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                            console.log(\"cost \" + eff.targetCard.map(({ cardName }) => cardName));\n                            divSelectMenuContainer.style.visibility = \"hidden\";\n                            disprayStage.removeAllChildren();\n                            yield discard(eff.targetCard);\n                            SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                            resolve();\n                        });\n                        SelectOkButton.addEventListener(\"click\", clickOkButton);\n                    });\n                    const cardlist = game.GY.filter(card => card instanceof SpellCard);\n                    openCardListWindow.select(cardlist, 1, 1, eff, \"手札に加える魔法を1枚選択してください\");\n                    const clickOkButton = (e) => __awaiter(this, void 0, void 0, function* () {\n                        divSelectMenuContainer.style.visibility = \"hidden\";\n                        disprayStage.removeAllChildren();\n                        SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                        yield animationEffectTarget(eff.targetCard);\n                        resolve();\n                    });\n                    SelectOkButton.addEventListener(\"click\", clickOkButton);\n                }));\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    if (eff.targetCard[0].location == \"GY\") {\n                        yield moveCard.GY.toHAND(eff.targetCard[0]);\n                        game.nowTime.move.push({\n                            card: eff.targetCard[0],\n                            from: \"GY\",\n                            to: \"HAND\"\n                        });\n                        yield ContinuousEffect(game.nowTime);\n                    }\n                    ;\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1];\n        },\n        HANDDESTRUCTION: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    JudgeSpellTrapActivateLoc(card),\n                    game.DECK.length >= game.HAND.filter(c => c !== card).length\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    resolve();\n                });\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    const count = game.HAND.length;\n                    yield discard(game.HAND);\n                    yield draw(count);\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1];\n        },\n        HURRICANE: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    JudgeSpellTrapActivateLoc(card),\n                    genCardArray({ location: [\"ST\"] }).filter(c => c != card).length > 0\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    resolve();\n                });\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    yield bounce(genCardArray({ location: [\"ST\"] }).filter(c => c != card), \"EFFECT\");\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1];\n        },\n        HIDDENARMORY: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    game.countNS == 0,\n                    JudgeSpellTrapActivateLoc(card),\n                    game.DECK.length >= 1,\n                    genCardArray({ cardType: [\"Spell\"], location: [\"DECK\", \"GY\"] })\n                        .filter(card => card instanceof SpellCard && card.spellType == \"Equip\").length >= 1\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    const decktop = game.DECK[game.DECK.length - 1];\n                    yield moveCard.DECK.toGY(decktop);\n                    game.nowTime.move.push({\n                        card: decktop,\n                        from: \"DECK\",\n                        to: \"GY\"\n                    });\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    const cardlist = genCardArray({ cardType: [\"Spell\"], location: [\"DECK\", \"GY\"] })\n                        .filter(card => card instanceof SpellCard && card.spellType == \"Equip\");\n                    if (cardlist.length > 0) {\n                        yield new Promise((resolve, reject) => {\n                            openCardListWindow.select(cardlist, 1, 1, eff, \"手札に加えるカードを選択してください\");\n                            SelectOkButton.addEventListener(\"click\", clickOkButton);\n                            function clickOkButton(e) {\n                                divSelectMenuContainer.style.visibility = \"hidden\";\n                                disprayStage.removeAllChildren();\n                                SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                                resolve();\n                            }\n                            ;\n                        });\n                        if (eff.targetCard[0].location == \"DECK\") {\n                            yield search(eff.targetCard);\n                        }\n                        else if (eff.targetCard[0].location == \"GY\") {\n                            yield moveCard.GY.toHAND(eff.targetCard[0]);\n                            game.nowTime.move.push({\n                                card: eff.card,\n                                from: \"GY\",\n                                to: \"HAND\"\n                            });\n                        }\n                        ;\n                        game.normalSummon = false;\n                    }\n                    ;\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1];\n        },\n        SPELLECONOMICS: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    JudgeSpellTrapActivateLoc(card)\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    resolve();\n                });\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    game.payLPcost = false;\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            const eff2 = new effect(card);\n            eff2.effType = \"Continuous\";\n            eff2.actionPossible = (time) => {\n                const timeCondition = (() => {\n                    const timeBoolArray = [];\n                    time.leaveBoard.forEach(tLeave => {\n                        timeBoolArray.push(tLeave.card == card);\n                    });\n                    return timeBoolArray.some(value => value);\n                })();\n                const boolarray = [timeCondition];\n                return boolarray.every(value => value == true);\n            };\n            eff2.apply = () => {\n                return new Promise((resolve, reject) => {\n                    game.payLPcost = true;\n                    resolve();\n                });\n            };\n            return [eff1, eff2];\n        },\n        GOLDSARCOPHAGUS: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.actionPossible = (time) => {\n                const boolarray = [\n                    JudgeSpellTrapActivateLoc(card),\n                    game.DECK.length >= 1\n                ];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    resolve();\n                });\n            };\n            eff1.whenResolve = (eff) => {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    if (game.DECK.length >= 1) {\n                        yield new Promise((resolve, reject) => {\n                            openCardListWindow.select(game.DECK, 1, 1, eff, \"除外するカードを選択してください\");\n                            SelectOkButton.addEventListener(\"click\", clickOkButton);\n                            function clickOkButton(e) {\n                                divSelectMenuContainer.style.visibility = \"hidden\";\n                                disprayStage.removeAllChildren();\n                                SelectOkButton.removeEventListener(\"click\", clickOkButton);\n                                resolve();\n                            }\n                            ;\n                        });\n                        yield vanish(eff.targetCard, \"EFFECT\");\n                        yield deckShuffle();\n                    }\n                    ;\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            };\n            return [eff1];\n        },\n        MAGICALEXPLOSION: (card) => {\n            const eff1 = new effect(card);\n            eff1.effType = \"CardActived\";\n            eff1.range = [\"HAND\", \"ST\"];\n            eff1.actionPossible = (time) => {\n                const boolarray = [false];\n                return boolarray.every(value => value == true);\n            };\n            eff1.whenActive = (eff) => {\n                return new Promise((resolve, reject) => {\n                    resolve();\n                });\n            };\n            eff1.whenResolve = (eff) => __awaiter(this, void 0, void 0, function* () {\n                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                    game.nowTime = new Time;\n                    const damage = game.GY.filter(c => c.cardType == \"Spell\").length * 200;\n                    yield dealDamage(damage);\n                    game.timeArray.push(Object.assign({}, game.nowTime));\n                    resolve();\n                }));\n            });\n            return [eff1];\n        }\n    };\n    const game = new Game;\n    const mainCanv = document.getElementById(\"canv\");\n    const mainstage = new createjs.Stage(mainCanv);\n    mainstage.enableMouseOver();\n    // if(createjs.Touch.isSupported() == true){\n    //     createjs.Touch.enable(mainstage)\n    // };\n    const statusCanv = document.getElementById(\"statuscanv\");\n    const statusStage = new createjs.Stage(statusCanv);\n    statusStage.enableMouseOver();\n    const statusCardNameText = document.getElementById(\"cardNameText\");\n    const statusCardTypeText = document.getElementById(\"cardTypeText\");\n    const statusCardEffText = document.getElementById(\"cardEffText\");\n    const divSelectMenuContainer = document.getElementById(\"selectMenuContainer\");\n    const windowBackCanv = document.getElementById(\"selectMenuBack\");\n    const windowBackStage = new createjs.Stage(windowBackCanv);\n    windowBackStage.enableMouseOver();\n    const selectButtonCanv = document.getElementById(\"selectButtonCanv\");\n    selectButtonCanv.style.width = String(windowSize.w) + \"px\";\n    selectButtonCanv.width = windowSize.w;\n    selectButtonCanv.style.height = String(60) + \"px\";\n    selectButtonCanv.height = 60;\n    const selectButtonStage = new createjs.Stage(selectButtonCanv);\n    selectButtonStage.enableMouseOver();\n    const messageText = document.getElementById(\"selectMessageText\");\n    const scrollAreaContainer = document.getElementById(\"scrollAreaContainer\");\n    scrollAreaContainer.style.width = String(windowSize.w) + \"px\";\n    scrollAreaContainer.style.height = String(windowSize.h) + \"px\";\n    const disprayCanv = document.getElementById(\"displayCanv\");\n    const disprayStage = new createjs.Stage(disprayCanv);\n    disprayStage.enableMouseOver();\n    // const tweetDOM = <HTMLElement>document.getElementById(\"twitterButton\");\n    // tweetDOM.style.visibility = \"hidden\";\n    setBoard(mainstage);\n    const cardContainer = new createjs.Container;\n    mainstage.addChild(cardContainer);\n    const myLP = new createjs.Text(game.myLifePoint.toString(), \"80px serif\", \"#4169e1\");\n    myLP.shadow = new createjs.Shadow(\"#58D3F7\", 0, 0, 20);\n    myLP.textBaseline = \"bottom\";\n    myLP.y = 800;\n    mainstage.addChild(myLP);\n    myLP.alpha = 0;\n    const EnemyLP = new createjs.Text(game.enemyLifePoint.toString(), \"80px serif\", \"#cd5c5c\");\n    EnemyLP.shadow = new createjs.Shadow(\"#FA5858\", 0, 0, 20);\n    EnemyLP.textAlign = \"left\";\n    mainstage.addChild(EnemyLP);\n    EnemyLP.alpha = 0;\n    const numOfcardsContainer = new createjs.Container;\n    const NumInDeck = new createjs.Text(\"DECK: \" + game.DECK.length.toString(), \"25px serif\", \"#000000\");\n    NumInDeck.textAlign = \"left\";\n    const NumInGy = new createjs.Text(\"SPELLS IN GY: \" + genCardArray({ location: [\"GY\"], cardType: [\"Spell\"] }).length.toString(), \"25px serif\", \"#000000\");\n    NumInGy.textAlign = \"left\";\n    numOfcardsContainer.addChild(NumInDeck);\n    numOfcardsContainer.addChild(NumInGy);\n    NumInGy.y = 40;\n    mainstage.addChild(numOfcardsContainer);\n    numOfcardsContainer.setTransform(game.displayOrder.deck[0][0] + 90, game.displayOrder.deck[0][1] - 60);\n    numOfcardsContainer.alpha = 0;\n    const updateText = new createjs.Text(\" /Update 2020.06.12_01 \", \"24px serif\", \"black\");\n    const createdbyText = new createjs.Text(\"Created by  \", \"24px serif\", \"black\");\n    const twiAccountText = new createjs.Text(\"@toride0313\", \"24px serif\", \"black\");\n    twiAccountText.x = createdbyText.getMeasuredWidth();\n    updateText.x = createdbyText.getMeasuredWidth() + twiAccountText.getMeasuredWidth() + 5;\n    twiAccountText.color = \"#1111cc\";\n    twiAccountText.cursor = \"pointer\";\n    const hitAreaShape = new createjs.Shape;\n    hitAreaShape.set({\n        graphics: new createjs.Graphics().beginFill(\"#FFF\").drawEllipse(0, 0, twiAccountText.getMeasuredWidth(), twiAccountText.getMeasuredHeight())\n    });\n    twiAccountText.hitArea = hitAreaShape;\n    const footerContainer = new createjs.Container;\n    footerContainer.addChild(createdbyText, twiAccountText, updateText);\n    twiAccountText.addEventListener(\"click\", clicktwiAccountText);\n    function clicktwiAccountText(event) {\n        window.open(\"https://twitter.com/toride0313\");\n    }\n    ;\n    mainstage.addChild(footerContainer);\n    footerContainer.y = 1000 - updateText.getMeasuredLineHeight();\n    const deckRecipe = [\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"Dogma\"], num: 3 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"CyberVary\"], num: 2 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"Airman\"], num: 1 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"Kuraz\"], num: 1 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"Disk\"], num: 1 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"MagicianOfChaos\"], num: 1 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"MonsterReborn\"], num: 1 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"MonsterGate\"], num: 3 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"Reasoning\"], num: 3 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"DestinyDraw\"], num: 3 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"HandDestruction\"], num: 1 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"HiddenArmory\"], num: 3 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"TradeIn\"], num: 2 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"PhenixBlade\"], num: 2 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"Reinforcement\"], num: 2 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"GoldSalcophagus\"], num: 1 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"DDR\"], num: 2 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"MagicStoneExcavation\"], num: 2 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"PrematureBrial\"], num: 1 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"Hurricane\"], num: 1 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"DimensionFusion\"], num: 1 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"SpellEconomics\"], num: 1 },\n        { json: _CardStatus_json__WEBPACK_IMPORTED_MODULE_2__[\"MagicalExplosion\"], num: 2 }\n    ];\n    deckRecipe.forEach((numOfCard, index, array) => {\n        const json = numOfCard.json;\n        for (let i = 0; i < numOfCard.num; i++) {\n            if (json[\"cardType\"] == \"Monster\") {\n                const monsterCardObj = genCardObject.Monster(json);\n                if (monsterCardObj.monsterType == \"Effect\") {\n                    if (effectSetting[monsterCardObj.effectKey] instanceof Function) {\n                        monsterCardObj.effect = effectSetting[monsterCardObj.effectKey](monsterCardObj);\n                    }\n                    ;\n                }\n                ;\n                if (!(monsterCardObj.canNS)) {\n                    SSconditionSetting[monsterCardObj.SSconditionKey](monsterCardObj);\n                }\n                ;\n                game.defaultDeck.push(monsterCardObj);\n            }\n            else if (json[\"cardType\"] == \"Spell\") {\n                const spellCardObj = genCardObject.Spell(json);\n                spellCardObj.effect = effectSetting[spellCardObj.effectKey](spellCardObj);\n                game.defaultDeck.push(spellCardObj);\n            }\n            else if (json[\"cardType\"] == \"Trap\") {\n                const trapCardObj = genCardObject.Trap(json);\n                trapCardObj.effect = effectSetting[trapCardObj.effectKey](trapCardObj);\n                game.defaultDeck.push(trapCardObj);\n            }\n            ;\n        }\n        ;\n    });\n    const viewCardback = new createjs.Bitmap(\"cardback_view.jpg\");\n    viewCardback.setTransform(statusCanv.width / 2, statusCanv.height / 2, 1, 1, 0, 0, 0, 140, 206);\n    statusStage.addChild(viewCardback);\n    lineUp();\n    console.log(game.DECK);\n    // const DeckViewButton = createButton(\"DECK View\", 150, 40, \"#0275d8\");\n    // DeckViewButton.x = 1200;\n    // DeckViewButton.y = 650;\n    // mainstage.addChild(DeckViewButton);\n    // DeckViewButton.on(\"click\", function(e){\n    //     openCardListWindow.view(game.DECK,\"DECK\");\n    //     console.log(game.DECK)\n    //     const clickOkButton = async (e) => {\n    //         divSelectMenuContainer.style.visibility = \"hidden\";\n    //         disprayStage.removeAllChildren();\n    //         SelectOkButton.removeEventListener(\"click\", clickOkButton);\n    //     };\n    //     SelectOkButton.addEventListener(\"click\",clickOkButton);\n    // }, null, false);\n    // const drawButton = createButton(\"draw\", 150, 40, \"#0275d8\");\n    // drawButton.x = 1300;\n    // drawButton.y = 500;\n    // mainstage.addChild(drawButton);\n    // drawButton.on(\"click\", function(e){\n    //     draw(1);\n    // }, null, false);\n    // const testButton = createButton(\"test\", 150, 40, \"#0275d8\");\n    // testButton.x = 1300;\n    // testButton.y = 550;\n    // mainstage.addChild(testButton);\n    // testButton.on(\"click\", function(e){\n    //     openHowtoWindow();\n    // }, null, false);\n    const startButton = Object(_createTextButton__WEBPACK_IMPORTED_MODULE_1__[\"createTextButton\"])(\"DUEL START\", \"80px serif\", \"midnightblue\", \"yellow\");\n    mainstage.addChild(startButton);\n    startButton.x = 550;\n    startButton.y = 850;\n    startButton.addEventListener(\"click\", handleClickStart);\n    function handleClickStart(event) {\n        gameStart();\n        createjs.Tween.get(startButton).to({ alpha: 0 }, 250);\n    }\n    ;\n    const TweetButtonImg = new createjs.Bitmap(\"tweet.png\");\n    TweetButtonImg.cursor = \"pointer\";\n    TweetButtonImg.x = 1275;\n    TweetButtonImg.y = 525;\n    mainstage.addChild(TweetButtonImg);\n    TweetButtonImg.on(\"click\", function (e) {\n        const url = \"https://twitter.com/share?url=https://tsd0313.github.io/ygo-DogmaBlade/dist/&related=twitterapi%2Ctwitter&hashtags=DogmaBladeSimulator&text=\" +\n            \"ドグマブレードシミュレータ\";\n        window.open(url, null, \"width=650, height=300, personalbar=0, toolbar=0, scrollbars=1, sizable=1\");\n    }, null, false);\n    const howtoButton = Object(_createButton__WEBPACK_IMPORTED_MODULE_0__[\"createButton\"])(\"HOW TO PLAY\", 160, 40, \"#0275d8\");\n    howtoButton.x = 1300;\n    howtoButton.y = 600;\n    mainstage.addChild(howtoButton);\n    howtoButton.on(\"click\", function (e) {\n        openHowtoWindow();\n    }, null, false);\n    const endButton = Object(_createButton__WEBPACK_IMPORTED_MODULE_0__[\"createButton\"])(\"TURN END\", 160, 80, \"#0275d8\");\n    endButton.x = 1300;\n    endButton.y = 660;\n    endButton.alpha = 0;\n    cardContainer.addChild(endButton);\n    endButton.on(\"click\", function async(e) {\n        gameEnd();\n    }, null, false);\n    const resetButton = Object(_createButton__WEBPACK_IMPORTED_MODULE_0__[\"createButton\"])(\"RESET\", 160, 80, \"#0275d8\");\n    resetButton.x = 1300;\n    resetButton.y = 750;\n    resetButton.alpha = 0;\n    cardContainer.addChild(resetButton);\n    resetButton.on(\"click\", function async(e) {\n        reset();\n    }, null, false);\n    createjs.Ticker.addEventListener(\"tick\", handleTick);\n    function handleTick() {\n        mainstage.update();\n        windowBackStage.update();\n        disprayStage.update();\n        selectButtonStage.update();\n        statusStage.update();\n        myLP.text = zerofix(game.myLifePoint);\n        EnemyLP.text = zerofix(game.enemyLifePoint);\n        NumInDeck.text = \"DECK : \" + zerofix(game.DECK.length);\n        NumInGy.text = \"GY : \" + zerofix(genCardArray({ location: [\"GY\"] }).length) + \" ( \" + zerofix(genCardArray({ location: [\"GY\"], cardType: [\"Spell\"] }).length) + \" )\";\n    }\n    ;\n    const selectMenuBack = new createjs.Shape();\n    selectMenuBack.graphics.beginFill(\"Gray\");\n    selectMenuBack.graphics.drawRect(0, 0, windowBackCanv.width, windowBackCanv.height);\n    selectMenuBack.alpha = 0.5;\n    windowBackStage.addChild(selectMenuBack);\n    const SelectOkButton = Object(_createButton__WEBPACK_IMPORTED_MODULE_0__[\"createButton\"])(\"OK\", 150, 40, \"#0275d8\");\n    SelectOkButton.x = selectButtonCanv.width / 2 - 75;\n    SelectOkButton.y = 10;\n    selectButtonStage.addChild(SelectOkButton);\n    const SelectCancelButton = Object(_createButton__WEBPACK_IMPORTED_MODULE_0__[\"createButton\"])(\"CANCEL\", 150, 40, \"#0275d8\");\n    SelectCancelButton.x = selectButtonCanv.width / 2 - 75;\n    SelectCancelButton.y = 10;\n    SelectCancelButton.visible = false;\n    selectButtonStage.addChild(SelectCancelButton);\n    const openCardListWindow = {\n        select: (cardArray, moreThan, lessThan, activeEff, message, cansel) => {\n            const disprayCards = [...cardArray].reverse();\n            divSelectMenuContainer.style.visibility = \"visible\";\n            SelectCancelButton.visible = false;\n            if (message == undefined) {\n                messageText.innerText = \"select\";\n            }\n            else {\n                messageText.innerText = message;\n            }\n            ;\n            if (cansel) {\n                SelectCancelButton.visible = true;\n                SelectOkButton.x = selectButtonCanv.width / 2 - 200;\n                SelectCancelButton.x = selectButtonCanv.width / 2 + 50;\n            }\n            else {\n                SelectOkButton.x = selectButtonCanv.width / 2 - 75;\n            }\n            ;\n            activeEff.targetCard = [];\n            selectedCardImgArray = [];\n            SelectOkButton.mouseEnabled = false;\n            disprayCanv.style.width = String((10 + cardImgSize.x) * disprayCards.length + 10) + \"px\";\n            disprayCanv.width = (10 + cardImgSize.x) * disprayCards.length + 10;\n            disprayCanv.style.height = String(50 + cardImgSize.y) + \"px\";\n            disprayCanv.height = 50 + cardImgSize.y;\n            const createLocLabelBox = (card) => {\n                const labelBox = new createjs.Container();\n                const labelBG = new createjs.Shape();\n                labelBG.graphics\n                    .setStrokeStyle(1)\n                    .beginStroke(\"black\")\n                    .beginFill(\"white\")\n                    .drawRoundRect(0.5, 0.5, cardImgSize.x - 1, 25 - 1, 0);\n                labelBox.addChild(labelBG);\n                const label = new createjs.Text(card.location, \"18px sans-serif\");\n                label.x = cardImgSize.x / 2;\n                label.y = 12.5;\n                label.textAlign = \"center\";\n                label.textBaseline = \"middle\";\n                labelBox.addChild(label);\n                return labelBox;\n            };\n            const PromiseArray = [];\n            disprayCards.map((card, index, array) => {\n                const ImgLabelContainer = new createjs.Container();\n                disprayStage.addChild(ImgLabelContainer);\n                const cardImgContainer = new createjs.Container();\n                const cardImg = new createjs.Bitmap(card.imageFileName);\n                cardImgContainer.addChild(cardImg);\n                if (card instanceof MonsterCard && 1 <= card.equip.length) {\n                    card.equip.forEach((equipSpell, i, array) => {\n                        const equipImg = new createjs.Bitmap(equipSpell.imageFileName);\n                        equipImg.setTransform(cardImgSize.x / 3 * i, cardImgSize.y * (2 / 3), 1 / 3, 1 / 3, -10, 0, 0, 0, 0);\n                        cardImgContainer.addChild(equipImg);\n                    });\n                }\n                ;\n                if (card instanceof SpellCard && 1 <= card.peggingTarget.length) {\n                    card.peggingTarget.forEach((equipTarget, i, array) => {\n                        const targetImg = new createjs.Bitmap(equipTarget.imageFileName);\n                        targetImg.setTransform(cardImgSize.x / 3 * i, cardImgSize.y * (2 / 3), 1 / 3, 1 / 3, -10, 0, 0, 0, 0);\n                        cardImgContainer.addChild(targetImg);\n                    });\n                }\n                ;\n                cardImgContainer.cursor = \"pointer\";\n                cardImgContainer.y = 0;\n                const selected = new createjs.Bitmap(\"selected.png\");\n                selected.setTransform(cardImgSize.x / 4, cardImgSize.y / 4, 0.5, 0.5);\n                selected.visible = false;\n                cardImgContainer.addChild(selected);\n                const selectedMouseOver = new createjs.Bitmap(\"selectedMouseOver.png\");\n                selectedMouseOver.setTransform(cardImgSize.x / 4, cardImgSize.y / 4, 0.5, 0.5);\n                selectedMouseOver.alpha = 0.5;\n                selectedMouseOver.visible = false;\n                cardImgContainer.addChild(selectedMouseOver);\n                const selectedCardImg = { imgContainer: cardImgContainer,\n                    selected: selected\n                };\n                const countCheck = (count) => {\n                    return [moreThan <= count, count <= lessThan].every(value => value);\n                };\n                cardImgContainer.addEventListener(\"mouseover\", handleSelectMover);\n                function handleSelectMover(event) {\n                    selectedMouseOver.visible = true;\n                }\n                ;\n                cardImgContainer.addEventListener(\"mouseout\", handleSelectMout);\n                function handleSelectMout(event) {\n                    selectedMouseOver.visible = false;\n                }\n                ;\n                cardImgContainer.addEventListener(\"click\", handleSelectClick);\n                function handleSelectClick(event) {\n                    if (selected.visible == false) {\n                        if (activeEff.targetCard.length == lessThan) {\n                            selectedCardImgArray[0].selected.visible = false;\n                            activeEff.targetCard.shift();\n                            selectedCardImgArray.shift();\n                        }\n                        ;\n                        selected.visible = true;\n                        activeEff.targetCard.push(card);\n                        selectedCardImgArray.push(selectedCardImg);\n                    }\n                    else {\n                        selected.visible = false;\n                        activeEff.targetCard = activeEff.targetCard.filter(i => i !== card);\n                        selectedCardImgArray = selectedCardImgArray.filter(i => i !== selectedCardImg);\n                    }\n                    ;\n                    SelectOkButton.mouseEnabled = countCheck(activeEff.targetCard.length);\n                    selectedMouseOver.visible = false;\n                }\n                ;\n                const newlabelBox = createLocLabelBox(card);\n                newlabelBox.y = cardImgSize.y + 10;\n                ImgLabelContainer.addChild(cardImgContainer);\n                SetStatusDisprayEvent(card, cardImgContainer);\n                ImgLabelContainer.addChild(newlabelBox);\n                ImgLabelContainer.x = 10 + ((10 + cardImgSize.x) * index);\n                ImgLabelContainer.y = 10;\n                ImgLabelContainer.alpha = 0;\n                const twPromise = () => {\n                    return new Promise((resolve, reject) => {\n                        createjs.Tween.get(ImgLabelContainer)\n                            .wait(50 * (index + 1))\n                            .to({ alpha: 1 }, 100)\n                            .call(() => { resolve(); });\n                    });\n                };\n                PromiseArray.push(twPromise());\n            });\n            return Promise.all(PromiseArray);\n        },\n        view: (cardArray, message) => {\n            const disprayCards = [...cardArray].reverse();\n            divSelectMenuContainer.style.visibility = \"visible\";\n            SelectCancelButton.visible = false;\n            SelectOkButton.x = selectButtonCanv.width / 2 - 75;\n            SelectOkButton.mouseEnabled = true;\n            if (message == undefined) {\n                messageText.innerText = \"select\";\n            }\n            else {\n                messageText.innerText = message;\n            }\n            ;\n            selectedCardImgArray = [];\n            disprayCanv.style.width = String((10 + cardImgSize.x) * disprayCards.length + 10) + \"px\";\n            disprayCanv.width = (10 + cardImgSize.x) * disprayCards.length + 10;\n            disprayCanv.style.height = String(50 + cardImgSize.y) + \"px\";\n            disprayCanv.height = 50 + cardImgSize.y;\n            const createLocLabelBox = (card) => {\n                const labelBox = new createjs.Container();\n                const labelBG = new createjs.Shape();\n                labelBG.graphics\n                    .setStrokeStyle(1)\n                    .beginStroke(\"black\")\n                    .beginFill(\"white\")\n                    .drawRoundRect(0.5, 0.5, cardImgSize.x - 1, 25 - 1, 0);\n                labelBox.addChild(labelBG);\n                const label = new createjs.Text(card.location, \"18px sans-serif\");\n                label.x = cardImgSize.x / 2;\n                label.y = 12.5;\n                label.textAlign = \"center\";\n                label.textBaseline = \"middle\";\n                labelBox.addChild(label);\n                return labelBox;\n            };\n            const PromiseArray = [];\n            disprayCards.map((card, index, array) => {\n                const ImgLabelContainer = new createjs.Container();\n                disprayStage.addChild(ImgLabelContainer);\n                const cardImgContainer = new createjs.Container();\n                const cardImg = new createjs.Bitmap(card.imageFileName);\n                cardImgContainer.addChild(cardImg);\n                cardImgContainer.cursor = \"pointer\";\n                cardImgContainer.y = 0;\n                const newlabelBox = createLocLabelBox(card);\n                newlabelBox.y = cardImgSize.y + 10;\n                ImgLabelContainer.addChild(cardImgContainer);\n                SetStatusDisprayEvent(card, cardImgContainer);\n                ImgLabelContainer.addChild(newlabelBox);\n                ImgLabelContainer.x = 10 + ((10 + cardImgSize.x) * index);\n                ImgLabelContainer.y = 10;\n                ImgLabelContainer.alpha = 0;\n                const twPromise = () => {\n                    return new Promise((resolve, reject) => {\n                        createjs.Tween.get(ImgLabelContainer)\n                            .wait(50 * (index + 1))\n                            .to({ alpha: 1 }, 100)\n                            .call(() => { resolve(); });\n                    });\n                };\n                PromiseArray.push(twPromise());\n            });\n            return Promise.all(PromiseArray);\n        }\n    };\n    const openYesNoWindow = (message) => {\n        divSelectMenuContainer.style.visibility = \"visible\";\n        SelectCancelButton.visible = false;\n        SelectOkButton.visible = false;\n        const YesNoContainer = new createjs.Container();\n        const YesButton = Object(_createButton__WEBPACK_IMPORTED_MODULE_0__[\"createButton\"])(\"YES\", 150, 40, \"#0275d8\");\n        YesNoContainer.addChild(YesButton);\n        const NoButton = Object(_createButton__WEBPACK_IMPORTED_MODULE_0__[\"createButton\"])(\"NO\", 150, 40, \"#0275d8\");\n        NoButton.x = NoButton.getBounds().width * 8;\n        YesNoContainer.addChild(NoButton);\n        YesNoContainer.regX = YesNoContainer.getBounds().width / 2;\n        YesNoContainer.regY = YesNoContainer.getBounds().height / 2;\n        YesNoContainer.x = windowSize.w / 2 - 60;\n        YesNoContainer.y = windowSize.h / 2;\n        disprayStage.addChild(YesNoContainer);\n        disprayCanv.style.width = String(windowSize.w) + \"px\";\n        disprayCanv.width = windowSize.w;\n        disprayCanv.style.height = String(windowSize.h) + \"px\";\n        disprayCanv.height = windowSize.h;\n        messageText.innerText = message;\n        return new Promise((resolve, reject) => {\n            YesButton.addEventListener(\"click\", clickYesButton);\n            function clickYesButton(e) {\n                divSelectMenuContainer.style.visibility = \"hidden\";\n                disprayStage.removeAllChildren();\n                SelectOkButton.visible = true;\n                resolve(true);\n            }\n            ;\n            NoButton.addEventListener(\"click\", clickNoButton);\n            function clickNoButton(e) {\n                divSelectMenuContainer.style.visibility = \"hidden\";\n                disprayStage.removeAllChildren();\n                SelectOkButton.visible = true;\n                resolve(false);\n            }\n            ;\n        });\n    };\n    const OpenPositionWindow = (card) => {\n        SelectOkButton.visible = false;\n        divSelectMenuContainer.style.visibility = \"visible\";\n        messageText.innerText = \"表示形式を選択\";\n        const AtkDefContainer = new createjs.Container();\n        disprayCanv.style.width = String(windowSize.w) + \"px\";\n        disprayCanv.width = windowSize.w;\n        disprayCanv.style.height = String(100 + cardImgSize.y) + \"px\";\n        disprayCanv.height = 100 + cardImgSize.y;\n        const Atk = new createjs.Container();\n        const AtkImg = new createjs.Bitmap(card.imageFileName);\n        Atk.addChild(AtkImg);\n        Atk.regX = Atk.getBounds().width / 2;\n        Atk.regY = Atk.getBounds().height / 2;\n        Atk.cursor = \"pointer\";\n        const Def = new createjs.Container();\n        const DefImg = new createjs.Bitmap(card.imageFileName);\n        Def.addChild(DefImg);\n        Def.regX = Def.getBounds().width / 2;\n        Def.regY = Def.getBounds().height / 2;\n        Def.cursor = \"pointer\";\n        Def.x = Def.getBounds().width * 2.5;\n        Def.rotation = -90;\n        AtkDefContainer.addChild(Atk);\n        AtkDefContainer.addChild(Def);\n        SetStatusDisprayEvent(card, Atk);\n        SetStatusDisprayEvent(card, Def);\n        AtkDefContainer.regX = AtkDefContainer.getBounds().width / 2;\n        AtkDefContainer.regY = AtkDefContainer.getBounds().height / 2;\n        AtkDefContainer.x = windowSize.w / 2 + 80;\n        AtkDefContainer.y = windowSize.h + 20;\n        disprayStage.addChild(AtkDefContainer);\n        return new Promise((resolve, reject) => {\n            Atk.addEventListener(\"click\", clickAtkButton);\n            function clickAtkButton(e) {\n                divSelectMenuContainer.style.visibility = \"hidden\";\n                disprayStage.removeAllChildren();\n                SelectOkButton.visible = true;\n                resolve(\"ATK\");\n            }\n            ;\n            Def.addEventListener(\"click\", clickNoButton);\n            function clickNoButton(e) {\n                divSelectMenuContainer.style.visibility = \"hidden\";\n                disprayStage.removeAllChildren();\n                SelectOkButton.visible = true;\n                resolve(\"DEF\");\n            }\n            ;\n        });\n    };\n    const OpenSelectEffectWindow = (card, messageA, messageB) => {\n        divSelectMenuContainer.style.visibility = \"visible\";\n        SelectCancelButton.visible = false;\n        SelectOkButton.visible = false;\n        const ChoiceContainer = new createjs.Container();\n        const Abutton = Object(_createButton__WEBPACK_IMPORTED_MODULE_0__[\"createButton\"])(messageA, 300, 150, \"#0275d8\");\n        ChoiceContainer.addChild(Abutton);\n        const Bbutton = Object(_createButton__WEBPACK_IMPORTED_MODULE_0__[\"createButton\"])(messageB, 300, 150, \"#0275d8\");\n        Bbutton.x = 400;\n        ChoiceContainer.addChild(Bbutton);\n        disprayCanv.style.width = String(windowSize.w) + \"px\";\n        disprayCanv.width = windowSize.w;\n        disprayCanv.style.height = String(windowSize.h) + \"px\";\n        disprayCanv.height = windowSize.h;\n        ChoiceContainer.regY = ChoiceContainer.getBounds().height / 2;\n        ChoiceContainer.x = 80;\n        ChoiceContainer.y = (disprayCanv.height - selectButtonCanv.height) / 2;\n        disprayStage.addChild(ChoiceContainer);\n        messageText.innerText = \"message\";\n        return new Promise((resolve, reject) => {\n            Abutton.addEventListener(\"click\", clickYesButton);\n            function clickYesButton(e) {\n                divSelectMenuContainer.style.visibility = \"hidden\";\n                disprayStage.removeAllChildren();\n                SelectOkButton.visible = true;\n                resolve(true);\n            }\n            ;\n            Bbutton.addEventListener(\"click\", clickNoButton);\n            function clickNoButton(e) {\n                divSelectMenuContainer.style.visibility = \"hidden\";\n                disprayStage.removeAllChildren();\n                SelectOkButton.visible = true;\n                resolve(false);\n            }\n            ;\n        });\n    };\n    const openResultWindow = (messageText) => __awaiter(this, void 0, void 0, function* () {\n        const resultWindowContainer = new createjs.Container();\n        const messageBack = new createjs.Shape();\n        messageBack.graphics.beginFill(\"white\");\n        messageBack.graphics.drawRect(0, 0, messageText.getMeasuredWidth() + 500, cardImgSize.y * 2);\n        messageBack.alpha = 0.5;\n        messageBack.regX = (messageText.getMeasuredWidth() + 500) / 2;\n        ;\n        messageBack.regY = cardImgSize.y;\n        messageText.x = 0;\n        messageText.y = 0;\n        const retryButton = Object(_createButton__WEBPACK_IMPORTED_MODULE_0__[\"createButton\"])(\"リトライ\", 150, 40, \"#0275d8\");\n        retryButton.x = -170;\n        retryButton.y = cardImgSize.y - 70;\n        const tweetButton = Object(_createButton__WEBPACK_IMPORTED_MODULE_0__[\"createButton\"])(\"結果をtweet\", 150, 40, \"#0275d8\");\n        tweetButton.x = 20;\n        tweetButton.y = cardImgSize.y - 70;\n        mainstage.enableMouseOver();\n        const tweetTextResult = (() => {\n            if (game.enemyLifePoint <= 0) {\n                return \"ドグマブレード先攻1キル成功！　\";\n            }\n            else {\n                return \"ドグマブレード先攻1キル失敗・・・　\";\n            }\n            ;\n        })();\n        const firstHand = \"初手→\" + game.firstHand.join('/') + \"\\n\";\n        const tweetURL = \"https://twitter.com/share?url=https://tsd0313.github.io/ygo-DogmaBlade/dist/&related=twitterapi%2Ctwitter&hashtags=DogmaBladeSimulator&text=\" +\n            tweetTextResult + firstHand;\n        retryButton.addEventListener(\"click\", clickRetryButton);\n        function clickRetryButton(event) {\n            location.reload();\n        }\n        ;\n        tweetButton.addEventListener(\"click\", clickTweetButton);\n        function clickTweetButton(event) {\n            // location.href = \"https://twitter.com/share?ref_src=twsrc%5Etfw\"\n            window.open(tweetURL, null, \"width=650, height=300, personalbar=0, toolbar=0, scrollbars=1, sizable=1\");\n        }\n        ;\n        mainstage.addChild(resultWindowContainer);\n        resultWindowContainer.addChild(messageBack, messageText, retryButton, tweetButton);\n        resultWindowContainer.setTransform(game.centerGrid.x, game.centerGrid.y);\n        resultWindowContainer.regX = 0;\n        resultWindowContainer.regY = 0;\n        resultWindowContainer.scaleX = 0;\n        resultWindowContainer.scaleY = 0;\n        messageText.alpha = 0;\n        retryButton.alpha = 0;\n        tweetButton.alpha = 0;\n        createjs.Tween.get(resultWindowContainer)\n            .to({ scaleX: 0.02, scaleY: 0.02 })\n            .to({ scaleX: 1 }, 250, createjs.Ease.cubicIn)\n            .to({ scaleY: 1 }, 250, createjs.Ease.cubicIn)\n            .call(() => {\n            createjs.Tween.get(messageText)\n                .to({ alpha: 1 }, 100);\n        })\n            .wait(1100)\n            .call(() => {\n            // tweetDOM.style.visibility = \"visible\";\n            [retryButton, tweetButton].forEach(button => {\n                createjs.Tween.get(button)\n                    .to({ alpha: 1 }, 100);\n            });\n        });\n        return;\n    });\n    const openMessageWindow = (message) => __awaiter(this, void 0, void 0, function* () {\n        const messageWindowContainer = new createjs.Container();\n        const messageWindowtext = new createjs.Text(message, \"30px serif\", \"black\");\n        messageWindowtext.textBaseline = \"middle\";\n        messageWindowtext.textAlign = \"center\";\n        const messageBack = new createjs.Shape();\n        messageBack.graphics.beginFill(\"white\");\n        messageBack.graphics.drawRect(0, 0, messageWindowtext.getMeasuredWidth() + 50, cardImgSize.y);\n        messageBack.alpha = 0.9;\n        messageBack.regX = (messageWindowtext.getMeasuredWidth() + 50) / 2;\n        ;\n        messageBack.regY = cardImgSize.y / 2;\n        mainstage.addChild(messageWindowContainer);\n        messageWindowContainer.addChild(messageBack, messageWindowtext);\n        messageWindowContainer.setTransform(game.grid.front[3][0], (game.grid.front[0][1] + game.grid.back[0][1]) / 2);\n        messageWindowContainer.regX = 0;\n        messageWindowContainer.regY = messageWindowContainer.getBounds().height / 2;\n        messageWindowContainer.scaleX = 0;\n        messageWindowContainer.scaleY = 0;\n        messageWindowtext.alpha = 0;\n        mainstage.setChildIndex(messageWindowContainer, mainstage.numChildren - 1);\n        yield new Promise((resolve, reject) => {\n            createjs.Tween.get(messageWindowContainer)\n                .to({ scaleX: 0.02, scaleY: 0.02 })\n                .to({ scaleX: 1 }, 250, createjs.Ease.cubicIn)\n                .to({ scaleY: 1 }, 250, createjs.Ease.cubicIn)\n                .call(() => {\n                createjs.Tween.get(messageWindowtext)\n                    .to({ alpha: 1 }, 100);\n            })\n                .wait(1100)\n                .call(() => {\n                createjs.Tween.get(messageWindowtext)\n                    .to({ alpha: 0 }, 100);\n            })\n                .to({ scaleY: 0.02 }, 250, createjs.Ease.cubicIn)\n                .to({ scaleX: 0 }, 250, createjs.Ease.cubicIn)\n                .call(() => { resolve(); });\n        });\n        mainstage.removeChild(messageWindowContainer);\n        return;\n    });\n    const openHowtoWindow = () => {\n        cardContainer.mouseEnabled = false;\n        howtoButton.mouseEnabled = false;\n        const messageA = \"ドグマブレードをぶん回し、先攻1ターンキルを達成しましょう。\";\n        const messageB = \"《D-HERO ドグマガイ》《マジカル・エクスプロージョン》はターン終了後に自動で発動します。\";\n        const messageC1 = \"デッキガイド：\";\n        const messageC2 = \" ドグマブレード｜ンマルギルドーニ｜note\";\n        const textA = new createjs.Text(messageA, \"24px serif\", \"black\");\n        const textB = new createjs.Text(messageB, \"24px serif\", \"black\");\n        const textC1 = new createjs.Text(messageC1, \"24px serif\", \"black\");\n        const textC2 = new createjs.Text(messageC2, \"24px serif\", \"black\");\n        textC2.color = \"#1111cc\";\n        textC2.cursor = \"pointer\";\n        const hitAreaShape = new createjs.Shape;\n        hitAreaShape.set({\n            graphics: new createjs.Graphics().beginFill(\"#FFF\").drawEllipse(0, 0, textC2.getMeasuredWidth(), textC2.getMeasuredHeight())\n        });\n        textC2.hitArea = hitAreaShape;\n        textC2.addEventListener(\"click\", clickTextC2);\n        function clickTextC2(event) {\n            window.open(\"https://note.com/gninallman3/n/nf330a71d5446\");\n        }\n        ;\n        const textCcontainer = new createjs.Container;\n        textCcontainer.addChild(textC1, textC2);\n        textC2.x = textC1.getMeasuredWidth();\n        const TextContainer = new createjs.Container();\n        [textA, textB, textCcontainer].forEach((obj, i, a) => {\n            TextContainer.addChild(obj);\n            obj.y = (textA.getMeasuredLineHeight() + 20) * i;\n        });\n        TextContainer.regX = TextContainer.getBounds().width / 2;\n        TextContainer.regY = TextContainer.getBounds().height / 2;\n        const messageBack = new createjs.Shape();\n        messageBack.graphics.beginFill(\"white\");\n        messageBack.graphics.drawRect(0, 0, TextContainer.getBounds().width + 50, TextContainer.getBounds().height + 200);\n        messageBack.alpha = 0.9;\n        messageBack.regX = (TextContainer.getBounds().width + 50) / 2;\n        messageBack.regY = (TextContainer.getBounds().height + 200) / 2;\n        const OkButton = Object(_createButton__WEBPACK_IMPORTED_MODULE_0__[\"createButton\"])(\"OK\", 150, 40, \"#0275d8\");\n        OkButton.regX = OkButton.getBounds().width / 2;\n        OkButton.regY = OkButton.getBounds().height / 2;\n        OkButton.x = -75;\n        OkButton.y = TextContainer.getBounds().height - 20;\n        OkButton.addEventListener(\"click\", clickOkButton);\n        function clickOkButton(event) {\n            mainstage.removeChild(HowtoWindowContainer);\n            cardContainer.mouseEnabled = true;\n            howtoButton.mouseEnabled = true;\n        }\n        ;\n        const HowtoWindowContainer = new createjs.Container();\n        HowtoWindowContainer.addChild(messageBack, TextContainer, OkButton);\n        HowtoWindowContainer.setTransform(game.centerGrid.x, game.centerGrid.y, 0, 0, 0, 0, 0, 0, 0);\n        mainstage.addChild(HowtoWindowContainer);\n        TextContainer.alpha = 0;\n        OkButton.alpha = 0;\n        createjs.Tween.get(HowtoWindowContainer)\n            .to({ scaleX: 0.02, scaleY: 0.02 })\n            .to({ scaleX: 1 }, 250, createjs.Ease.cubicIn)\n            .to({ scaleY: 1 }, 250, createjs.Ease.cubicIn)\n            .call(() => {\n            [TextContainer, OkButton].forEach(obj => {\n                createjs.Tween.get(obj)\n                    .to({ alpha: 1 }, 100);\n            });\n        });\n    };\n};\n\n\n//# sourceURL=webpack:///./src/main.ts?");

/***/ })

/******/ });